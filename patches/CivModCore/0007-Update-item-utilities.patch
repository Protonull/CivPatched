From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alexander <protonull@protonmail.com>
Date: Sat, 13 May 2023 18:22:41 +0100
Subject: [PATCH] Update item utilities

Add getRepairable to ItemUtils, which is pretty identical to getDamageable, except it returns the Repairable type instead.

Add getMaterials to MaterialUtils, which returns a Set of all Materials.

Add AmountMap, which is a more robust and efficient replacement of Map<?, Integer> and a preliminary replacement to ItemMap.

Add ISerializer and update NBTHelper to use it.

Standardises NBTSerializationException.

diff --git a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java
index f84ec069bd4bd46c38f473c1eb06d47bce8576c5..cf7f1dc1b28b25a5e7f9279c767bf6e5b4aa8162 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java
@@ -18,6 +18,11 @@ import org.bukkit.inventory.meta.ItemMeta;
 import org.jetbrains.annotations.Contract;
 import vg.civcraft.mc.civmodcore.chat.ChatUtils;
 
+// CivPatched Start
+import org.bukkit.inventory.meta.Repairable;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 /**
  * Class of static APIs for Items. Replaces ISUtils.
  */
@@ -188,6 +193,39 @@ public final class ItemUtils {
 		return CraftItemStack.asNMSCopy(item);
 	}
 
+	// CivPatched Start
+	/**
+	 * Splits an item into safely-size stacks based on the given item's amount.
+	 */
+	public static @NotNull List<@NotNull ItemStack> segmentItem(
+			final @NotNull ItemStack template
+	) {
+		return segmentItem(template, template.getAmount());
+	}
+	/**
+	 * Splits an item into safely-sized stacks based on the given amount.
+	 */
+	public static @NotNull List<@NotNull ItemStack> segmentItem(
+			final @NotNull ItemStack template,
+			final int amount
+	) {
+		final int maxStackSize = template.getType().getMaxStackSize();
+		if (maxStackSize > amount) {
+			return Arrays.asList(template.asQuantity(amount)); // Ignore the highlighter, List.of() is unmodifiable
+		}
+		final int fullStacks = amount / maxStackSize;
+		final int partStack = amount % maxStackSize;
+		final List<ItemStack> result = new ArrayList<>(fullStacks + (partStack > 0 ? 1 : 0));
+		for (int i = 0; i < fullStacks; i++) {
+			result.add(template.asQuantity(maxStackSize));
+		}
+		if (partStack > 0) {
+			result.add(template.asQuantity(partStack));
+		}
+		return result;
+	}
+	// CivPatched End
+
 	/**
 	 * Decrements an item's amount, or returns null if the amount reaches zero.
 	 *
@@ -410,6 +448,26 @@ public final class ItemUtils {
 		return null;
 	}
 
+	// CivPatched Start
+	/**
+	 * Retrieves the Repairable ItemMeta only if it's relevant to the item. This is necessary because [almost?] every
+	 * ItemMeta implements Repairable... for some reason. And so this will only return a Repairable instance if the
+	 * item material actually has a maximum durability above zero.
+	 */
+	public static @Nullable Repairable getRepairable(final @Nullable ItemStack item) {
+		if (item == null) {
+			return null;
+		}
+		final Material material = item.getType();
+		if (isValidItemMaterial(material)
+				&& material.getMaxDurability() > 0
+				&& getItemMeta(item) instanceof Repairable repairable) {
+			return repairable;
+		}
+		return null;
+	}
+	// CivPatched End
+
 	/**
 	 * Makes an item glow by adding an enchantment and the flag for hiding enchantments, so it has the enchantment glow
 	 * without an enchantment being visible. Note that this does actually apply an enchantment to an item.
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java
index 7613b5129e55b275e1122e4e709d8b11aa19d568..8e22ae05e1c631c91f57fb5ddf216dacee72fef8 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java
@@ -14,6 +14,12 @@ import org.bukkit.Material;
 import org.bukkit.Tag;
 import org.bukkit.inventory.ItemStack;
 
+// CivPatched Start
+import java.util.HashSet;
+import java.util.Set;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 /**
  * <p>See <a href="https://github.com/Protonull/BukkitReport/tree/master/reports">BukkitReports</a>.</p>
  *
@@ -34,6 +40,18 @@ public final class MaterialUtils {
 		addAll(MaterialTags.CONCRETES.getValues());
 	}};
 
+	// CivPatched Start
+	public final Set<Material> MATERIALS = Set.of(Material.values());
+	/**
+	 * @return Returns a new material set. DO NOT USE {@link java.util.EnumSet<Material>}! As it'll force load all
+	 * materials, including all legacy materials, forcing the server into legacy mode. For some reason
+	 * {@link Material#values()} doesn't do that... odd.
+	 */
+	public @NotNull Set<Material> getMaterials() {
+		return new HashSet<>(MATERIALS);
+	}
+	// CivPatched End
+
 	/**
 	 * Attempts to retrieve a material by its slug.
 	 *
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
index eeeced8ac5c0f39119145f76f0811164d18da730..e0bd7dad25467052623234d2d9b9112da134f743 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
@@ -1,19 +1,29 @@
 package vg.civcraft.mc.civmodcore.nbt;
 
 import java.util.UUID;
-import lombok.experimental.ExtensionMethod;
 import lombok.experimental.UtilityClass;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.inventory.ItemStack;
 import vg.civcraft.mc.civmodcore.inventory.items.ItemUtils;
-import vg.civcraft.mc.civmodcore.nbt.extensions.NBTTagCompoundExtensions;
 import vg.civcraft.mc.civmodcore.nbt.wrappers.NBTCompound;
 import vg.civcraft.mc.civmodcore.utilities.UuidUtils;
 
+// CivPatched Start
+import java.util.logging.Level;
+import net.minecraft.nbt.CompoundTag;
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.inventory.Inventory;
+import org.jetbrains.annotations.NotNull;
+import vg.civcraft.mc.civmodcore.utilities.CivLogger;
+import vg.civcraft.mc.civmodcore.utilities.serialization.ISerializer;
+// CivPatched End
+
 @UtilityClass
-@ExtensionMethod(NBTTagCompoundExtensions.class)
-public final class NBTHelper {
+// CivPatched Start
+public class NBTHelper {
+	private final CivLogger LOGGER = CivLogger.getLogger(NBTHelper.class);
+	// CivPatched End
 
 	// ------------------------------------------------------------
 	// Location
@@ -26,56 +36,143 @@ public final class NBTHelper {
 	private static final String LOCATION_YAW_KEY = "yaw";
 	private static final String LOCATION_PITCH_KEY = "pitch";
 
-	public static Location locationFromNBT(final NBTCompound nbt) {
-		if (nbt == null) {
-			return null;
+	// CivPatched Start
+	public final ISerializer.NBT<Location> LOCATION = new ISerializer.NBT<>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull Location location) {
+			final var nbt = new CompoundTag();
+			try {
+				nbt.putUUID(LOCATION_WORLD_KEY, location.getWorld().getUID());
+			}
+			catch (final Throwable ignored) {
+				nbt.putUUID(LOCATION_WORLD_KEY, UuidUtils.IDENTITY);
+			}
+			nbt.putDouble(LOCATION_X_KEY, location.getX());
+			nbt.putDouble(LOCATION_Y_KEY, location.getY());
+			nbt.putDouble(LOCATION_Z_KEY, location.getZ());
+			final float yaw = location.getYaw();
+			if (yaw != 0) {
+				nbt.putFloat(LOCATION_YAW_KEY, yaw);
+			}
+			final float pitch = location.getPitch();
+			if (pitch != 0) {
+				nbt.putFloat(LOCATION_PITCH_KEY, pitch);
+			}
+			return nbt;
+		}
+		@Override
+		public @NotNull Location deserialize(final @NotNull CompoundTag nbt) {
+			final UUID worldUUID = nbt.getUUID(LOCATION_WORLD_KEY);
+			return new Location(
+					UuidUtils.isNullOrIdentity(worldUUID) ? null : Bukkit.getWorld(worldUUID),
+					nbt.getDouble(LOCATION_X_KEY),
+					nbt.getDouble(LOCATION_Y_KEY),
+					nbt.getDouble(LOCATION_Z_KEY),
+					nbt.getFloat(LOCATION_YAW_KEY),
+					nbt.getFloat(LOCATION_PITCH_KEY));
 		}
-		final UUID worldUUID = nbt.getUUID(LOCATION_WORLD_KEY);
-		return new Location(
-				UuidUtils.isNullOrIdentity(worldUUID) ? null : Bukkit.getWorld(worldUUID),
-				nbt.getDouble(LOCATION_X_KEY),
-				nbt.getDouble(LOCATION_Y_KEY),
-				nbt.getDouble(LOCATION_Z_KEY),
-				nbt.getFloat(LOCATION_YAW_KEY),
-				nbt.getFloat(LOCATION_PITCH_KEY));
+	};
+	// CivPatched End
+
+	public static Location locationFromNBT(final NBTCompound nbt) {
+		return nbt == null ? null : LOCATION.deserialize(nbt.getRAW()); // CivPatched
 	}
 
 	public static NBTCompound locationToNBT(final Location location) {
-		if (location == null) {
-			return null;
-		}
-		final var nbt = new NBTCompound();
-		nbt.setUUID(LOCATION_WORLD_KEY, location.isWorldLoaded() ? location.getWorld().getUID() : UuidUtils.IDENTITY);
-		nbt.setDouble(LOCATION_X_KEY, location.getX());
-		nbt.setDouble(LOCATION_Y_KEY, location.getY());
-		nbt.setDouble(LOCATION_Z_KEY, location.getZ());
-		if (location.getYaw() != 0) {
-			nbt.setFloat(LOCATION_YAW_KEY, location.getYaw());
-		}
-		if (location.getPitch() != 0) {
-			nbt.setFloat(LOCATION_PITCH_KEY, location.getPitch());
-		}
-		return nbt;
+		return location == null ? null : new NBTCompound(LOCATION.serialize(location)); // CivPatched
 	}
 
 	// ------------------------------------------------------------
 	// ItemStack
 	// ------------------------------------------------------------
 
-	public static ItemStack itemStackFromNBT(final NBTCompound nbt) {
-		if (nbt == null) {
-			return null;
+	// CivPatched Start
+	public final ISerializer.NBT<ItemStack> ITEMSTACK = new ISerializer.NBT<>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull ItemStack item) {
+			final var nbt = new CompoundTag();
+			ItemUtils.getNMSItemStack(item).save(nbt);
+			return nbt;
+		}
+		@Override
+		public @NotNull ItemStack deserialize(final @NotNull CompoundTag nbt) {
+			return net.minecraft.world.item.ItemStack.of(nbt).getBukkitStack();
 		}
-		return net.minecraft.world.item.ItemStack.of(nbt.getRAW()).getBukkitStack();
+	};
+	// CivPatched End
+
+	public static ItemStack itemStackFromNBT(final NBTCompound nbt) {
+		return nbt == null ? null : ITEMSTACK.deserialize(nbt.getRAW()); // CivPatched
 	}
 
 	public static NBTCompound itemStackToNBT(final ItemStack item) {
-		if (item == null) {
-			return null;
-		}
-		final var nbt = new NBTCompound();
-		ItemUtils.getNMSItemStack(item).save(nbt.getRAW());
-		return nbt;
+		return item == null ? null : new NBTCompound(ITEMSTACK.serialize(item)); // CivPatched
 	}
 
+	// ------------------------------------------------------------
+	// Inventory
+	// ------------------------------------------------------------
+
+	// CivPatched Start
+	public final ISerializer.NBT<Inventory> INVENTORY = new ISerializer.NBT<Inventory>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull Inventory inventory) {
+			final var nbt = new CompoundTag();
+			final ItemStack[] contents = inventory.getContents();
+			for (int i = 0; i < contents.length; i++) {
+				final ItemStack item = contents[i];
+				if (!ItemUtils.isEmptyItem(item)) {
+					nbt.put(Integer.toString(i), ITEMSTACK.serialize(item));
+				}
+			}
+			return nbt;
+		}
+		public void deserialize(
+				final @NotNull Inventory inventory,
+				final @NotNull CompoundTag nbt
+		) {
+			inventory.clear();
+			final ItemStack[] contents = inventory.getContents();
+			for (final String key : nbt.getAllKeys()) {
+				if (!(nbt.get(key) instanceof final CompoundTag compound)) {
+					LOGGER.log(
+							Level.WARNING,
+							"Inventory slot [" + key + "] is not a parsable NBT compound!",
+							new RuntimeException()
+					);
+					continue;
+				}
+				final ItemStack parsed = ITEMSTACK.deserialize(compound);
+				if (ItemUtils.isEmptyItem(parsed)) {
+					// Just ignore empty items
+					continue;
+				}
+				final int index;
+				try {
+					index = Integer.parseInt(key);
+				}
+				catch (final NumberFormatException thrown) {
+					LOGGER.log(Level.WARNING,
+							"Inventory slot [" + key + "] not a valid number! Item[" + parsed + "] will be ignored.",
+							new RuntimeException());
+					continue;
+				}
+				if (index < 0 || index >= contents.length) {
+					LOGGER.log(Level.WARNING,
+							"Inventory slot [" + index + "] is out of bounds of array[" + contents.length + "]! Item[" + parsed + "] will be ignored.",
+							new RuntimeException());
+					continue;
+				}
+				contents[index] = parsed;
+			}
+			inventory.setContents(contents);
+		}
+		@Deprecated
+		@Override
+		public @NotNull Inventory deserialize(final @NotNull CompoundTag raw) {
+			throw new NotImplementedException();
+		}
+	};
+	// CivPatched End
+
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java
index 8b4eb90deac0e9fc34c62448177b3e7fad6d49bc..3586d1e72aee2fa9b5b16e752131a3ad66e344e8 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java
@@ -7,25 +7,10 @@ import vg.civcraft.mc.civmodcore.nbt.wrappers.NBTCompound;
  * Exception that ought to be used within {@link NBTSerializable#toNBT(NBTCompound)} and
  * {@link NBTSerializable#fromNBT(NBTCompound)}.
  */
+@lombok.experimental.StandardException // CivPatched
 public class NBTSerializationException extends RuntimeException {
 
 	@Serial
 	private static final long serialVersionUID = 606023177729327630L;
 
-	public NBTSerializationException() {
-		super();
-	}
-
-	public NBTSerializationException(String message) {
-		super(message);
-	}
-
-	public NBTSerializationException(String message, Throwable cause) {
-		super(message, cause);
-	}
-
-	public NBTSerializationException(Throwable cause) {
-		super(cause);
-	}
-
 }
\ No newline at end of file
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ef13fec94d69ad677a04f3667bcbe260785adbf
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java
@@ -0,0 +1,129 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import it.unimi.dsi.fastutil.ints.Int2IntFunction;
+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMaps;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import java.util.Objects;
+import org.apache.commons.lang3.NotImplementedException;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An attempt to fix the ever-present problem of tracking amounts. There are two default implementations:
+ * {@link ArrayMap} and {@link HashMap}. Be aware that this class doesn't support key preprocessing, so you <i>will</i>
+ * need to manually call {@link org.bukkit.inventory.ItemStack#asOne()} for example if you intend to use items.
+ *
+ * @author CivPatched
+ */
+public interface AmountMap<T> extends Object2IntMap<T> {
+
+	/**
+	 * Removes "empties", ie: keys with non-positive amounts.
+	 */
+	default void removeEmpties() {
+		values().removeIf((final int amount) -> amount <= 0);
+	}
+
+	/**
+	 * @return Returns the total amount of things stored in this map.
+	 */
+	default int getTotalAmount() {
+		int amount = 0;
+		for (final int currentAmount : values()) {
+			if (currentAmount > 0) {
+				amount += currentAmount;
+			}
+		}
+		return amount;
+	}
+
+	/**
+	 * Computes the amount for a certain key. If the computer returns a non-positive amount, the key is considered
+	 * "empty" and will be removed.
+	 *
+	 * @param key The key to compute the amount of.
+	 * @param computer The computer method/lambda to call.
+	 * @return Returns the new amount value, or zero if "empty".
+	 */
+	default int computeAmount(
+            final T key,
+            final @NotNull Int2IntFunction computer
+    ) {
+		return computeInt(key, (final T _key, Integer amount) -> {
+			amount = computer.applyAsInt(amount == null ? defaultReturnValue() : amount);
+			return amount <= 0 ? null : amount;
+		});
+	}
+
+	/**
+	 * Convenience method to add a particular amount to a given key.
+	 *
+	 * @param key The key to add to.
+	 * @param amount The amount to add, which can be null.
+	 * @return Returns the new amount value, or zero if "empty".
+	 */
+	default int changeAmountBy(
+            final T key,
+            final int amount
+    ) {
+		return computeAmount(key, (final int currentAmount) -> currentAmount + amount);
+	}
+
+	/**
+	 * @deprecated Changing the default value from 0 in an amount map is not supported!
+	 */
+	@Deprecated
+	@Override
+	default void defaultReturnValue(final int returnValue) {
+		throw new NotImplementedException("Please don't try to change the default return value!");
+	}
+
+	// ------------------------------------------------------------
+	// Default Implementations
+	// ------------------------------------------------------------
+
+	/**
+	 * Predefined increment method useful for {@link #computeAmount(Object, Int2IntFunction)}.
+	 */
+	Int2IntFunction INCREMENT = (final int amount) -> amount + 1;
+
+	/**
+	 * Predefined decrement method useful for {@link #computeAmount(Object, Int2IntFunction)}.
+	 */
+	Int2IntFunction DECREMENT = (final int amount) -> amount - 1;
+
+	/**
+	 * Array-map implementation class for {@link AmountMap}.
+	 */
+	class ArrayMap<T> extends Object2IntArrayMap<T> implements AmountMap<T> {
+		public ArrayMap() {
+			this(16);
+		}
+		public ArrayMap(final int size) {
+			super(size);
+		}
+	}
+
+	/**
+	 * Hash-map implementation class for {@link AmountMap}.
+	 */
+	class HashMap<T> extends Object2IntOpenHashMap<T> implements AmountMap<T> {
+		public HashMap() {
+			this(16);
+		}
+		public HashMap(final int size) {
+			super(size);
+		}
+	}
+
+	/**
+	 * Wrapper class to make an {@link AmountMap} unmodifiable.
+	 */
+	class Unmodifiable<T> extends Object2IntMaps.UnmodifiableMap<T> implements AmountMap<T> {
+		public Unmodifiable(final @NotNull AmountMap<T> map) {
+			super(Objects.requireNonNull(map));
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/serialization/ISerializer.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/serialization/ISerializer.java
new file mode 100644
index 0000000000000000000000000000000000000000..dd195ceea046e659e7687ee5c51a1ab238cc4f55
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/serialization/ISerializer.java
@@ -0,0 +1,147 @@
+package vg.civcraft.mc.civmodcore.utilities.serialization;
+
+import java.util.Objects;
+import lombok.Synchronized;
+import net.minecraft.nbt.CompoundTag;
+import org.bukkit.persistence.PersistentDataAdapterContext;
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.NotNull;
+import vg.civcraft.mc.civmodcore.nbt.NBTDeserializer;
+import vg.civcraft.mc.civmodcore.nbt.NBTSerializable;
+import vg.civcraft.mc.civmodcore.nbt.NBTSerialization;
+import vg.civcraft.mc.civmodcore.nbt.wrappers.NBTCompound;
+
+/**
+ * This is a class inspired by {@link NBTSerializable} and {@link PersistentDataType} and is designed to act as a bridge
+ * between them while not being specific to either.
+ *
+ * @author CivPatched
+ */
+public interface ISerializer<T, R> {
+
+    @NotNull R serialize(@NotNull T instance);
+
+    @NotNull T deserialize(@NotNull R raw);
+
+    /**
+     * Template interface for byte serialization.
+     *
+     * @param <C> The type that can be serialised to and from byte data.
+     */
+    interface Bytes<C> extends ISerializer<C, byte[]> {
+
+    }
+
+    /**
+     * Template interface for NBT serialization.
+     *
+     * @param <C> The type that can be serialised to and from NBT.
+     */
+    interface NBT<C> extends ISerializer<C, CompoundTag> {
+
+    }
+
+    /**
+     * Template that wraps legacy NBT serialization methods.
+     *
+     * @param <C> The type that can be serialised to and from NBT.
+     */
+    class LegacyNBT<C extends NBTSerializable> implements ISerializer<C, NBTCompound> {
+        private final NBTDeserializer<C> deserializer;
+
+        /**
+         * @param deserializer The serializable's version of {@link NBTSerializable#fromNBT(NBTCompound) fromNBT(NBTCompound)}
+         */
+        public LegacyNBT(final @NotNull NBTDeserializer<C> deserializer) {
+            this.deserializer = Objects.requireNonNull(deserializer);
+        }
+
+        /**
+         * @param serializableClass The serializable's class to extract the deserializer from.
+         */
+        public LegacyNBT(final @NotNull Class<C> serializableClass) {
+            this(NBTSerialization.getDeserializer(serializableClass));
+        }
+
+        /** {@inheritDoc} */
+        @Override
+        public @NotNull NBTCompound serialize(final @NotNull C instance) {
+            final var nbt = new NBTCompound();
+            instance.toNBT(nbt);
+            return nbt;
+        }
+
+        /** {@inheritDoc} */
+        @Override
+        public @NotNull C deserialize(final @NotNull NBTCompound raw) {
+            return this.deserializer.fromNBT(raw);
+        }
+    }
+
+    /**
+     * Template that wraps PersistentDataContainer serialization.
+     *
+     * @param <C> The <b>C</b>omplex type.
+     * @param <P> The <b>P</b>rimitive type.
+     */
+    abstract class PDC<C, P> implements ISerializer<C, P>, PersistentDataType<P, C> {
+        private final Class<C> complexClass;
+        private final Class<P> primitiveClass;
+        private PersistentDataAdapterContext adapter;
+
+        public PDC(
+                final @NotNull Class<C> complexClass,
+                final @NotNull Class<P> primitiveClass
+        ) {
+            this.complexClass = Objects.requireNonNull(complexClass);
+            this.primitiveClass = Objects.requireNonNull(primitiveClass);
+        }
+
+        protected final @NotNull PersistentDataAdapterContext getAdapter() {
+            return this.adapter;
+        }
+
+        /** {@inheritDoc} */
+        public final @NotNull Class<C> getComplexType() {
+            return this.complexClass;
+        }
+
+        /** {@inheritDoc} */
+        public final @NotNull Class<P> getPrimitiveType() {
+            return this.primitiveClass;
+        }
+
+        /** {@inheritDoc} */
+        @Deprecated
+        @Synchronized
+        public final @NotNull P toPrimitive(
+                final @NotNull C complex,
+                final @NotNull PersistentDataAdapterContext context
+        ) {
+            this.adapter = context;
+            try {
+                return serialize(complex);
+            }
+            finally {
+                this.adapter = null;
+            }
+        }
+
+        /** {@inheritDoc} */
+        @Deprecated
+        @Synchronized
+        public final @NotNull C fromPrimitive(
+                final @NotNull P primitive,
+                final @NotNull PersistentDataAdapterContext context
+        ) {
+            this.adapter = context;
+            try {
+                return deserialize(primitive);
+            }
+            finally {
+                this.adapter = null;
+            }
+        }
+    }
+
+}
\ No newline at end of file
