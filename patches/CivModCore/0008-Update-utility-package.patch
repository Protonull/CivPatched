From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alexander <protonull@protonmail.com>
Date: Thu, 13 Jul 2023 04:55:15 +0100
Subject: [PATCH] Update utility package

Added AmountMap.

CivLogger:
- Added inject().

DependencyGlue:
- Updated getDependencyInstance().
- Updated isDependencyEnabled().
- Updated registerGlue().
- Privatised INTERNAL_onServerLoad().
- Privatised INTERNAL_onPluginEnable().
- Privatised INTERNAL_onPluginDisable().

Added DeprecationUtils.

Added IndexUtils.

Added JavaHelpers.

KeyedUtils:
- Added toStrings().
- Added dittoKey().

Added MoreEnumUtils.

Added MoreIterationUtils.

MoreMapUtils:
- Overhauled attemptGet().
- Added computeAll().
- Added mapEntry().

MoreMath:
- Added isWithinBounds().

MoreStringUtils:
- Added getCharStrings().

NullUtils:
- Added mapIfPresent().
- Added nonNullMapper().

Added Encoder.

TextTests:
- Added testSplitEquality().

diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..50611ddc6cd6a8198b44eb37b1287023889ea4e7
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java
@@ -0,0 +1,145 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMaps;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import java.util.Objects;
+import java.util.function.IntUnaryOperator;
+import org.apache.commons.lang3.NotImplementedException;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An attempt to fix the ever-present problem of tracking amounts. There are two default implementations:
+ * {@link ArrayMap} and {@link HashMap}. Be aware that this class doesn't support key preprocessing, so you <i>will</i>
+ * need to manually call {@link org.bukkit.inventory.ItemStack#asOne()} for example if you intend to use items.
+ *
+ * @author CivPatched
+ */
+public interface AmountMap<T> extends Object2IntMap<T> {
+	/**
+	 * Removes "empties", ie: keys with non-positive amounts.
+	 */
+	default void removeEmpties() {
+		values().removeIf((amount) -> amount <= 0);
+	}
+
+	/**
+	 * @return Returns the total amount of things stored in this map.
+	 */
+	default int getTotalAmount() {
+		int amount = 0;
+		for (final int currentAmount : values()) {
+			if (currentAmount > 0) {
+				amount += currentAmount;
+			}
+		}
+		return amount;
+	}
+
+	/**
+	 * Computes the amount for a certain key. If the computer returns a non-positive amount, the key is considered
+	 * "empty" and will be removed.
+	 *
+	 * @param key The key to compute the amount of.
+	 * @param computer The computer method/lambda to call.
+	 * @return Returns the new amount value, or zero if "empty".
+	 */
+	default int computeAmount(
+            final T key,
+            final @NotNull IntUnaryOperator computer
+    ) {
+		return computeInt(key, (final T _key, Integer amount) -> {
+			amount = computer.applyAsInt(amount == null ? defaultReturnValue() : amount);
+			return amount <= 0 ? null : amount;
+		});
+	}
+
+	/**
+	 * Convenience method to add a particular amount to a given key.
+	 *
+	 * @param key The key to add to.
+	 * @param amount The amount to add, which can be null.
+	 * @return Returns the new amount value, or zero if "empty".
+	 */
+	default int changeAmountBy(
+            final T key,
+            final int amount
+    ) {
+		return computeAmount(key, (currentAmount) -> currentAmount + amount);
+	}
+
+	/**
+	 * Convenience function to increase the amount of a key by one.
+	 */
+	default int increment(
+			final T key
+	) {
+		return computeAmount(key, INCREMENT);
+	}
+
+	/**
+	 * Convenience function to decrease the amount of a key by one.
+	 */
+	default int decrement(
+			final T key
+	) {
+		return computeAmount(key, DECREMENT);
+	}
+
+	/**
+	 * @deprecated Changing the default value from 0 in an amount map is not supported!
+	 */
+	@Deprecated
+	@Override
+	default void defaultReturnValue(final int returnValue) {
+		throw new NotImplementedException("Please don't try to change the default return value!");
+	}
+
+	// ------------------------------------------------------------
+	// Default Implementations
+	// ------------------------------------------------------------
+
+	/**
+	 * Predefined increment method useful for {@link #computeAmount(Object, IntUnaryOperator)}.
+	 */
+	IntUnaryOperator INCREMENT = (amount) -> amount + 1;
+
+	/**
+	 * Predefined decrement method useful for {@link #computeAmount(Object, IntUnaryOperator)}.
+	 */
+	IntUnaryOperator DECREMENT = (amount) -> amount - 1;
+
+	/**
+	 * Array-map implementation class for {@link AmountMap}.
+	 */
+	class ArrayMap<T> extends Object2IntArrayMap<T> implements AmountMap<T> {
+		public ArrayMap() {
+			this(16);
+		}
+		public ArrayMap(final int size) {
+			super(size);
+		}
+	}
+
+	/**
+	 * Hash-map implementation class for {@link AmountMap}.
+	 */
+	class HashMap<T> extends Object2IntOpenHashMap<T> implements AmountMap<T> {
+		public HashMap() {
+			this(16);
+		}
+		public HashMap(final int size) {
+			super(size);
+		}
+	}
+
+	/**
+	 * Wrapper class to make an {@link AmountMap} unmodifiable.
+	 */
+	class Unmodifiable<T> extends Object2IntMaps.UnmodifiableMap<T> implements AmountMap<T> {
+		public Unmodifiable(final @NotNull AmountMap<T> map) {
+			super(Objects.requireNonNull(map));
+		}
+	}
+}
\ No newline at end of file
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/CivLogger.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/CivLogger.java
index 335f7b2d5f528999872a2ac55fc19ffc780de202..b1ff9da40ea3b317ab9468ad52c1650121646599 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/utilities/CivLogger.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/CivLogger.java
@@ -14,6 +14,23 @@ import org.bukkit.plugin.java.PluginClassLoader;
 
 public final class CivLogger extends Logger {
 
+	// CivPatched Start
+	public static @Nonnull Logger inject(
+			final @Nonnull Logger logger,
+			final @Nonnull java.util.function.Consumer<LogRecord> handler
+	) {
+		final var wrapper = new Logger(null, null) {
+			@Override
+			public void log(final LogRecord record) {
+				handler.accept(record);
+				super.log(record);
+			}
+		};
+		wrapper.setParent(logger);
+		return wrapper;
+	}
+	// CivPatched End
+
 	private final String prefix;
 
 	private CivLogger(@Nonnull final Logger logger, @Nonnull final String prefix) {
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/DependencyGlue.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/DependencyGlue.java
index c94ee254c64b875443c027b70360ffbddc39dad3..b9ecde2334e474bdc90766ef494cbbd126d8d468 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/utilities/DependencyGlue.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/DependencyGlue.java
@@ -3,7 +3,6 @@ package vg.civcraft.mc.civmodcore.utilities;
 import java.util.Objects;
 import java.util.logging.Logger;
 import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
 import org.apache.commons.lang3.StringUtils;
 import org.bukkit.Bukkit;
 import org.bukkit.event.EventHandler;
@@ -13,7 +12,10 @@ import org.bukkit.event.server.PluginDisableEvent;
 import org.bukkit.event.server.PluginEnableEvent;
 import org.bukkit.event.server.ServerLoadEvent;
 import org.bukkit.plugin.Plugin;
-import org.bukkit.plugin.PluginManager;
+
+// CivPatched Start
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
 
 /**
  * Class designed to make creating glue classes easier, particularly with soft dependencies where your plugins may use
@@ -23,7 +25,6 @@ import org.bukkit.plugin.PluginManager;
  */
 public abstract class DependencyGlue implements Listener {
 
-	private final PluginManager pluginManager;
 	protected final Plugin plugin;
 	protected final Logger logger;
 	protected final String dependencyName;
@@ -36,7 +37,6 @@ public abstract class DependencyGlue implements Listener {
 	 * @param dependencyName The name of the plugin you wish to glue.
 	 */
 	protected DependencyGlue(@Nonnull final Plugin plugin, @Nonnull final String dependencyName) {
-		this.pluginManager = Bukkit.getPluginManager();
 		this.plugin = Objects.requireNonNull(plugin);
 		this.logger = CivLogger.getLogger(plugin.getClass(), getClass());
 		this.dependencyName = Objects.requireNonNull(dependencyName);
@@ -55,23 +55,24 @@ public abstract class DependencyGlue implements Listener {
 	/**
 	 * @return Returns the current dependency instance.
 	 */
-	@Nullable
-	public Plugin getDependencyInstance() {
-		return this.dependencyInstance;
+	// CivPatched Start: Make this non-nullable
+	public @NotNull Plugin getDependencyInstance() {
+		return Objects.requireNonNull(this.dependencyInstance, "You're attempting to get dependency instance when it's not enabled!");
+		// CivPatched End
 	}
 
 	/**
 	 * @return Returns true if the dependency is currently enabled.
 	 */
 	public boolean isDependencyEnabled() {
-		return this.pluginManager.isPluginEnabled(this.dependencyInstance);
+		return Bukkit.getPluginManager().isPluginEnabled(this.dependencyInstance); // CivPatched: Get plugin manager directly
 	}
 
 	/**
 	 * Will register this glue with Bukkit.
 	 */
 	public void registerGlue() {
-		this.pluginManager.registerEvents(this, this.plugin);
+		Bukkit.getPluginManager().registerEvents(this, this.plugin); // CivPatched: Get plugin manager directly
 	}
 
 	/**
@@ -92,7 +93,7 @@ public abstract class DependencyGlue implements Listener {
 	protected abstract void onDependencyDisabled();
 
 	@EventHandler
-	public final void INTERNAL_onServerLoad(final ServerLoadEvent event) {
+	private void INTERNAL_onServerLoad(final ServerLoadEvent event) { // CivPatched: Make private
 		for (final Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
 			if (plugin.isEnabled() && StringUtils.equalsIgnoreCase(plugin.getName(), this.dependencyName)) {
 				this.dependencyInstance = plugin;
@@ -104,7 +105,7 @@ public abstract class DependencyGlue implements Listener {
 	}
 
 	@EventHandler
-	public final void INTERNAL_onPluginEnable(final PluginEnableEvent event) {
+	private void INTERNAL_onPluginEnable(final PluginEnableEvent event) { // CivPatched: Make private
 		if (StringUtils.equalsIgnoreCase(event.getPlugin().getName(), this.dependencyName)) {
 			this.dependencyInstance = event.getPlugin();
 			INTERNAL_logDependencyEnabled();
@@ -113,7 +114,7 @@ public abstract class DependencyGlue implements Listener {
 	}
 
 	@EventHandler
-	public final void INTERNAL_onPluginDisable(final PluginDisableEvent event) {
+	private void INTERNAL_onPluginDisable(final PluginDisableEvent event) { // CivPatched: Make private
 		if (StringUtils.equalsIgnoreCase(event.getPlugin().getName(), this.dependencyName)) {
 			INTERNAL_logDependencyDisabled();
 			onDependencyDisabled();
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/DeprecationUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/DeprecationUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..89729b9edbb19a52ad70fb0ecfc0db06a9a35611
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/DeprecationUtils.java
@@ -0,0 +1,37 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import lombok.experimental.StandardException;
+import lombok.experimental.UtilityClass;
+import org.bukkit.Bukkit;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author CivPatched
+ */
+@UtilityClass
+public class DeprecationUtils {
+    private final Logger LOGGER = Bukkit.getLogger();
+
+    /**
+     * Prints a warning to Bukkit's console with a stacktrace warning of
+     * deprecation usages.
+     */
+    public void printDeprecationWarning() {
+        printDeprecationWarning("You are using a deprecated feature. Please consider updating to its recommended replacement.");
+    }
+
+    /**
+     * Prints your warning message to Bukkit's console with a stacktrace
+     * warning of deprecation usages.
+     */
+    public void printDeprecationWarning(final @NotNull String message) {
+        LOGGER.log(Level.WARNING, message, new DeprecationException());
+    }
+
+    @StandardException
+    public static class DeprecationException extends RuntimeException {
+
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/IndexUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/IndexUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..d999e001dd3711390a77bcc54a5520bc41e97068
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/IndexUtils.java
@@ -0,0 +1,60 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import com.google.common.collect.BiMap;
+import com.google.common.collect.HashBiMap;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Set;
+import java.util.function.Function;
+import lombok.experimental.UtilityClass;
+import net.kyori.adventure.util.Index;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author CivPatched
+ */
+@UtilityClass
+public class IndexUtils {
+    /**
+     * Creates a new index based on a given index, including the given values.
+     */
+    public <K, E> @NotNull Index<K, E> with(
+            final @NotNull Index<K, E> index,
+            final @NotNull Function<@NotNull E, @NotNull K> keyGetter,
+            final @NotNull Collection<@NotNull E> elements
+    ) {
+        return Index.create(
+                keyGetter,
+                MoreIterationUtils.combine(
+                        ArrayList::new,
+                        index.values(),
+                        elements
+                )
+        );
+    }
+
+    /**
+     * Creates a new index based on a given index, excluding the values by the given keys.
+     */
+    public <K, E> @NotNull Index<K, E> without(
+            final @NotNull Index<K, E> index,
+            final @NotNull Function<@NotNull E, @NotNull K> keyGetter,
+            final @NotNull Set<@NotNull K> keys
+    ) {
+        final var currentValues = new ArrayList<>(index.values());
+        currentValues.removeIf((value) -> keys.contains(keyGetter.apply(value)));
+        return Index.create(
+                keyGetter,
+                currentValues
+        );
+    }
+
+    /**
+     * Creates a BiMap based on the given index.
+     */
+    public <K, E> @NotNull BiMap<K, E> asBiMap(
+            final @NotNull Index<K, E> index
+    ) {
+        return HashBiMap.create(index.keyToValue());
+    }
+}
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/JavaHelpers.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/JavaHelpers.java
new file mode 100644
index 0000000000000000000000000000000000000000..17f829f8f27c606b131c146e29b0536637e07894
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/JavaHelpers.java
@@ -0,0 +1,35 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import java.util.Objects;
+import java.util.function.Function;
+import java.util.function.Supplier;
+import lombok.experimental.UtilityClass;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author CivPatched
+ */
+@UtilityClass
+public class JavaHelpers {
+    /**
+     * Convenience function to yield a value from multiple lines, inline.
+     * Keep an eye on: https://openjdk.org/jeps/447
+     */
+    public <T> T yield(
+            final @NotNull Supplier<T> supplier
+    ) {
+        return supplier.get();
+    }
+
+    /**
+     * Convenience function similar in nature to {@link Objects#requireNonNullElseGet(Object, Supplier)}, except it
+     * allows for a unitary function intended for small functions, usually methods, like {@link Object#clone()}.
+     */
+    public <T> T compute(
+            final T value,
+            final @NotNull Function<@NotNull T, T> ifPresent,
+            final @NotNull Supplier<@NotNull T> orElse
+    ) {
+        return value == null ? orElse.get() : ifPresent.apply(value);
+    }
+}
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/KeyedUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/KeyedUtils.java
index 02224e523a22acf75efc35816ea07c962ebd3129..88f855d9ed235bb3e6d266859fb3947aa7bd13e2 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/utilities/KeyedUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/KeyedUtils.java
@@ -6,11 +6,32 @@ import lombok.experimental.UtilityClass;
 import org.bukkit.Keyed;
 import org.bukkit.NamespacedKey;
 
+// CivPatched Start
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.List;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 /**
  * Utility class to make dealing with namespace keys easier.
  */
 @UtilityClass
 public final class KeyedUtils {
+	// CivPatched Start
+	/**
+	 * Convert a collection of keyed-instances into a representative collection of strings.
+	 */
+	public <T extends Keyed> @NotNull Collection<@NotNull String> toStrings(
+			final Collection<@NotNull T> keyeds
+	) {
+		final var strings = new ArrayList<String>(keyeds.size());
+		for (final Keyed keyed : keyeds) {
+			strings.add(keyed.getKey().asString());
+		}
+		return List.copyOf(strings);
+	}
+	// CivPatched End
 
 	/**
 	 * Converts a stringified namespaced-key back into a {@link NamespacedKey}.
@@ -36,7 +57,6 @@ public final class KeyedUtils {
 	 * @exception IllegalArgumentException Will throw if either part fails a "[a-z0-9._-]+" check, or if the total
 	 *     combined length is longer than 256.
 	 */
-	@SuppressWarnings("deprecation")
 	@Nonnull
 	public static NamespacedKey fromParts(@Nonnull final String namespace, @Nonnull final String key) {
 		return new NamespacedKey(namespace, key);
@@ -68,10 +88,19 @@ public final class KeyedUtils {
 	 * @param key The namespaced-key.
 	 * @return Returns a new {@link NamespacedKey} for testing purposes.
 	 */
-	@SuppressWarnings("deprecation")
 	@Nonnull
 	public static NamespacedKey testKey(@Nonnull final String key) {
 		return new NamespacedKey("test", key);
 	}
 
+	// CivPatched Start
+	/**
+	 * Creates a <a href="https://www.merriam-webster.com/dictionary/ditto">ditto</a> key. Useful for nested keys.
+	 */
+	public @NotNull NamespacedKey dittoKey(
+			final @NotNull String key
+	) {
+		return new NamespacedKey(".", key);
+	}
+	// CivPatched End
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreEnumUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreEnumUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..b6d4284a65fd8c52a6aadc5825f724bc7331b04c
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreEnumUtils.java
@@ -0,0 +1,67 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import lombok.experimental.UtilityClass;
+import org.apache.commons.lang3.EnumUtils;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * Utility class that fills in the gaps of {@link EnumUtils}.
+ *
+ * @author CivPatched
+ */
+@UtilityClass
+public class MoreEnumUtils {
+    /**
+     * @param <E> The enum type itself.
+     * @param value The enum value to stringify.
+     * @return Returns a string-version of the given enum, or "null".
+     */
+    public <E extends Enum<E>> @NotNull String getName(
+            final E value
+    ) {
+        return value == null ? "null" : value.name();
+    }
+
+    /**
+     * @param <E> The enum type itself.
+     * @param enumClass The enum class to get the names of.
+     * @return Returns a set of all enum-names of the given enum-class.
+     */
+    public <E extends Enum<E>> @NotNull Collection<@NotNull String> getNames(
+            final @NotNull Class<E> enumClass
+    ) {
+        return getNames(enumClass.getEnumConstants());
+    }
+
+    /**
+     * @param <E> The enum type itself.
+     * @param enums The enums to convert into names.
+     * @return Returns a set of all enum-names of the given enums.
+     */
+    public <E extends Enum<E>> @NotNull Collection<@NotNull String> getNames(
+            final E @NotNull [] enums
+    ) {
+        final var result = new ArrayList<String>(enums.length);
+        for (final E current : enums) {
+            result.add(getName(current));
+        }
+        return result;
+    }
+
+    /**
+     * @param <E> The enum type itself.
+     * @param enums The enums to convert into names.
+     * @return Returns a set of all enum-names of the given enums.
+     */
+    public <E extends Enum<E>> @NotNull Collection<@NotNull String> getNames(
+            final @NotNull Collection<E> enums
+    ) {
+        final var result = new ArrayList<String>(enums.size());
+        for (final E current : enums) {
+            result.add(getName(current));
+        }
+        return result;
+    }
+}
\ No newline at end of file
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreIterationUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreIterationUtils.java
new file mode 100644
index 0000000000000000000000000000000000000000..26a227550383d294c1f324c903dd97d52c293bc5
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreIterationUtils.java
@@ -0,0 +1,197 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Map;
+import java.util.function.BiPredicate;
+import java.util.function.Function;
+import java.util.function.IntFunction;
+import java.util.function.Predicate;
+import lombok.experimental.UtilityClass;
+import org.apache.commons.collections4.IterableUtils;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * @author CivPatched
+ */
+@UtilityClass
+public class MoreIterationUtils {
+    /**
+     * @param <T> The iterator's element type.
+     * @param iterator The iterator to remove elements from.
+     * @param predicate The method to test entries with. It should return true to remove that entry.
+     */
+    public <T> void removeIf(
+            final @NotNull Iterator<T> iterator,
+            final @NotNull Predicate<T> predicate
+    ) {
+        while (iterator.hasNext()) {
+            if (predicate.test(iterator.next())) {
+                iterator.remove();
+            }
+        }
+    }
+
+    /**
+     * @param <T> The iterable's element type.
+     * @param iterable The iterable to remove elements from.
+     * @param predicate The method to test entries with. It should return true to remove that entry.
+     */
+    public <T> void removeIf(
+            final @NotNull Iterable<T> iterable,
+            final @NotNull Predicate<T> predicate
+    ) {
+        removeIf(iterable.iterator(), predicate);
+    }
+
+    /**
+     * This is useful when wanting to separate elements into groups based on
+     * shared data. For example, this could be used to group a collection of
+     * locations by their world. Each unique world would be a kay, and the
+     * value would be a list of all the locations with that world.
+     */
+    public <E, K> @NotNull Map<K, List<E>> groupIntoMapByKey(
+            final @NotNull Collection<E> collection,
+            final @NotNull Function<E, K> discriminator
+    ) {
+        final var map = new HashMap<K, List<E>>(collection.size());
+        for (final var element : collection) {
+            map.computeIfAbsent(
+                    discriminator.apply(element),
+                    (key) -> new ArrayList<>()
+            ).add(element);
+        }
+        return map;
+    }
+
+    /**
+     * Attempts to retrieve an element from an array based on a given index. Negative indexes index relative to the end
+     * of the array.
+     */
+    public <T> T getElement(
+            final T @NotNull [] array,
+            final int index
+    ) {
+        if (index >= 0) {
+            return array[index];
+        }
+        return array[array.length + index];
+    }
+
+    /**
+     * Attempts to retrieve an element from a collection based on a given index. Negative indexes index relative to the
+     * end of the collection.
+     */
+    public <T> T getElement(
+            final @NotNull Collection<T> collection,
+            final int index
+    ) {
+        if (index >= 0) {
+            return IterableUtils.get(collection, index);
+        }
+        return IterableUtils.get(collection, collection.size() + index);
+    }
+
+    /**
+     * Checks whether a given collection of elements are contained within a
+     * reference collection, returning all elements that are NOT contained.
+     */
+    public <T> @NotNull Collection<T> getMissing(
+            final @NotNull Collection<T> from,
+            @NotNull Collection<T> elements
+    ) {
+        elements = new ArrayList<>(elements);
+        elements.removeIf(from::contains);
+        return elements;
+    }
+
+    /**
+     * Iterates through two arrays checking that each element is equal to its counterpart according to the given
+     * predicate.
+     */
+    public <T> boolean areEqual(
+            final T[] lhs,
+            final T[] rhs,
+            final @NotNull BiPredicate<T, T> checker
+    ) {
+        if (lhs == rhs) {
+            return true;
+        }
+        if (lhs == null ^ rhs == null) {
+            return false;
+        }
+        if (lhs.length != rhs.length) {
+            return false;
+        }
+        for (int i = 0; i < lhs.length; i++) {
+            if (!checker.test(lhs[i], rhs[i])) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Iterates through two collections checking that each element is equal to its counterpart according to the given
+     * predicate.
+     */
+    public <T> boolean areEqual(
+            final Collection<T> lhs,
+            final Collection<T> rhs,
+            final @NotNull BiPredicate<T, T> checker
+    ) {
+        if (lhs == rhs) {
+            return true;
+        }
+        if (lhs == null ^ rhs == null) {
+            return false;
+        }
+        if (lhs.size() != rhs.size()) {
+            return false;
+        }
+        final Iterator<T> lhsIterator = lhs.iterator(), rhsIterator = rhs.iterator();
+        while (lhsIterator.hasNext() && rhsIterator.hasNext()) {
+            if (!checker.test(lhsIterator.next(), rhsIterator.next())) {
+                return false;
+            }
+        }
+        return true;
+    }
+
+    /**
+     * Collects varargs together into a collection of your choosing. This is basically a mutable version of
+     * {@link List#of(Object[])}.
+     */
+    @SafeVarargs
+    public <E, C extends Collection<E>> @NotNull C collect(
+            final @NotNull IntFunction<@NotNull C> constructor,
+            final E @NotNull ... elements
+    ) {
+        final C collection = constructor.apply(elements.length);
+        Collections.addAll(collection, elements);
+        return collection;
+    }
+
+    /**
+     * Combines a series of collections into a singular collection.
+     */
+    @SafeVarargs
+    public <E, C extends Collection<E>> C combine(
+            final @NotNull IntFunction<C> constructor,
+            final @NotNull Collection<E> @NotNull ... collections
+    ) {
+        int size = 0;
+        for (final Collection<E> collection : collections) {
+            size += collection.size();
+        }
+        final C result = constructor.apply(size);
+        for (final Collection<E> collection : collections) {
+            result.addAll(collection);
+        }
+        return result;
+    }
+}
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMapUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMapUtils.java
index 7d3cf8949491b914933ce445e4e545d8fe22871e..09daa3ea03a2c11e8596b73dd01773f808cd21b4 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMapUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMapUtils.java
@@ -9,6 +9,12 @@ import lombok.experimental.UtilityClass;
 import org.apache.commons.collections4.MapUtils;
 import org.apache.commons.lang3.ArrayUtils;
 
+// CivPatched Start
+import java.util.function.BiFunction;
+import java.util.List;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 /**
  * Utility class that fills in the gaps of {@link MapUtils}.
  *
@@ -61,64 +67,61 @@ public final class MoreMapUtils {
 		return null;
 	}
 
+	// CivPatched Start
 	/**
-	 * Attempts to retrieve a value from a given map from a range of keys.
-	 *
-	 * @param <K> The key type of the map.
-	 * @param <V> The value type of the map.
-	 * @param <R> The desired return type.
-	 * @param map The map to retrieve the value from.
-	 * @param fallback The value that should be returned if none of the keys return a [valid] value.
-	 * @param keys The keys to check.
-	 * @return Returns a value, either from the keys or the fallback, both of which may be null.
+	 * @return Returns the first non-null value at the given keys, or null.
 	 */
-	@SafeVarargs
-	public static <K, V, R> R attemptGet(final Map<K, V> map, final R fallback, final K... keys) {
-		return attemptGet(map, null, fallback, keys);
+	public <K, V> V attemptGet(
+			final @NotNull Map<K, V> map,
+			final @NotNull List<@NotNull K> keys
+	) {
+		return attemptGet(map, keys, null);
 	}
-
 	/**
-	 * Attempts to retrieve a value from a given map from a range of keys.
-	 *
-	 * @param <K> The key type of the map.
-	 * @param <V> The value type of the map.
-	 * @param <R> The desired return type.
-	 * @param map The map to retrieve the value from.
-	 * @param parser The function to process the value from the map. Null will use a default parser.
-	 * @param fallback The value that should be returned if none of the keys return a [valid] value.
-	 * @param keys The keys to check.
-	 * @return Returns a value, either from the keys or the fallback, both of which may be null.
+	 * @return Returns the first non-null value at the given keys, or the given fallback.
 	 */
-	@SafeVarargs
-	@SuppressWarnings("unchecked")
-	public static <K, V, R> R attemptGet(final Map<K, V> map,
-										 final Function<V, R> parser,
-										 final R fallback,
-										 final K... keys) {
-		if (parser == null) {
-			// Default parser (basic cast)
-			return attemptGet(map, (V v) -> (R) v, fallback, keys);
-		}
-		if (MapUtils.isEmpty(map) || ArrayUtils.isEmpty(keys)) {
-			return fallback;
-		}
+	public <K, V> V attemptGet(
+			final @NotNull Map<K, V> map,
+			final @NotNull List<@NotNull K> keys,
+			final V fallback
+	) {
 		for (final K key : keys) {
-			if (!map.containsKey(key)) {
-				continue;
-			}
-			try {
-				return parser.apply(map.get(key));
-			}
-			// Yeeeaaaah, I know this is a catch all exception and that's bad, but this really could be anything since
-			// the parser function could be anything.. it could be a class cast, a null reference, number format...
-			// But since this is a value parser and not an arbitrary code executor, nothing complication will be run,
-			// so any exception cab be interpreted as a bad or unexpected value.
-			catch (final Throwable ignored) {
-				return fallback;
+			final V value = map.get(key);
+			if (value != null) {
+				return value;
 			}
 		}
 		return fallback;
 	}
+	/**
+	 * Computes every key-value paid in the map.
+	 */
+	public <K, V> void computeAll(
+			final @NotNull Map<K, V> map,
+			final @NotNull BiFunction<K, V, V> computer
+	) {
+		for (final var iterator = map.entrySet().iterator(); iterator.hasNext();) {
+			final var entry = iterator.next();
+			final var computedValue = computer.apply(
+					entry.getKey(),
+					entry.getValue()
+			);
+			if (computedValue == null) {
+				iterator.remove();
+				continue;
+			}
+			entry.setValue(computedValue);
+		}
+	}
+	/**
+	 * Convenience function to make mapping entry-sets less aids.
+	 */
+	public <K, V, R> @NotNull Function<Map.Entry<K, V>, R> mapEntry(
+			final @NotNull BiFunction<K, V, R> mapper
+	) {
+		return (entry) -> mapper.apply(entry.getKey(), entry.getValue());
+	}
+	// CivPatched End
 
 	/**
 	 * Sets all the given keys a particular value.
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMath.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMath.java
index 84d134d202a2c9955eb94e2183235d10be41e052..8a67687aed9a54598fe5fee74f454e03a8be82c4 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMath.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreMath.java
@@ -185,4 +185,46 @@ public final class MoreMath {
 		return value < 0 ? Math.ceil(value) : Math.floor(value);
 	}
 
+	// CivPatched Start
+	/**
+	 * Tests whether a given value is within a minimum and maximum bounds.
+	 */
+	public boolean isWithinBounds(
+			final int value,
+			final int min,
+			final int max
+	) {
+		return value >= min && value <= max;
+	}
+	/**
+	 * Tests whether a given value is within a minimum and maximum bounds.
+	 */
+	public boolean isWithinBounds(
+			final long value,
+			final long min,
+			final long max
+	) {
+		return value >= min && value <= max;
+	}
+	/**
+	 * Tests whether a given value is within a minimum and maximum bounds.
+	 */
+	public boolean isWithinBounds(
+			final float value,
+			final float min,
+			final float max
+	) {
+		return value >= min && value <= max;
+	}
+	/**
+	 * Tests whether a given value is within a minimum and maximum bounds.
+	 */
+	public boolean isWithinBounds(
+			final double value,
+			final double min,
+			final double max
+	) {
+		return value >= min && value <= max;
+	}
+	// CivPatched End
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreStringUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreStringUtils.java
index 91937661adbe7395864a4ceb09a1e925a74b2b76..f3dc6b8f3f3b54ee18dc4bd31bdeaea327d63d4e 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreStringUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/MoreStringUtils.java
@@ -6,6 +6,12 @@ import org.apache.commons.collections4.CollectionUtils;
 import org.apache.commons.lang3.ArrayUtils;
 import org.apache.commons.lang3.StringUtils;
 
+// CivPatched Start
+import java.text.BreakIterator;
+import java.util.ArrayList;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 @UtilityClass
 public class MoreStringUtils {
 
@@ -39,4 +45,33 @@ public class MoreStringUtils {
 		return joinOxfordComma(strings, ", ", " and ");
 	}
 
+	// CivPatched Start
+	/**
+	 * Splits a string into an array of its constituent characters, respecting
+	 * UTF-32 characters. For example, this will split "{@code 😀😁😂}" into
+	 * {@code ["😀", "😁", "😂"]}, whereas {@link String#toCharArray()} will
+	 * produce {@code ['\uD83D', '\uDE00', '\uD83D', '\uDE01', '\uD83D', '\uDE02']}.
+	 */
+	public String[] getCharStrings(
+			final @NotNull String string
+	) {
+		if (string.isEmpty()) {
+			return new String[0];
+		}
+
+		final BreakIterator iterator = BreakIterator.getCharacterInstance();
+		iterator.setText(string);
+
+		int start = iterator.first();
+		int end = iterator.next();
+		final var result = new ArrayList<String>(string.length() * 2);
+		while (end != BreakIterator.DONE) {
+			result.add(string.substring(start, end));
+			start = end;
+			end = iterator.next();
+		}
+
+		return result.toArray(String[]::new);
+	}
+	// CivPatched End
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/NullUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/NullUtils.java
index b6cc83872716bfedc2b4114ad3fc920294f78a4f..d83155a1a87e8a991e6ac253d4397467ff17dd78 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/utilities/NullUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/NullUtils.java
@@ -3,6 +3,11 @@ package vg.civcraft.mc.civmodcore.utilities;
 import javax.annotation.Nonnull;
 import lombok.experimental.UtilityClass;
 
+// CivPatched Start
+import java.util.function.Function;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 /**
  * @author Protonull
  */
@@ -56,4 +61,31 @@ public final class NullUtils {
 		return object;
 	}
 
+	// CivPatched Start
+	/**
+	 * Maps a value if it's non-null.
+	 * @return Returns null if the given value is null, or otherwise whatever the mapper returned.
+	 */
+	public <T, R> R mapIfPresent(
+			final T value,
+			final @NotNull Function<T, R> mapper
+	) {
+		return value == null ? null : mapper.apply(value);
+	}
+	/**
+	 * <p>Converts {@link #mapIfPresent(Object, Function)} into a functional-lambda.
+	 * You'll no longer have to do:</p>
+	 *
+	 * <p>{@code MoreArrayUtils.computeElements(array, (ele) -> NullUtils.mapIfPresent(ele, this::someFunc))}</p>
+	 *
+	 * <p>You can instead do:</p>
+	 *
+	 * <p>{@code MoreArrayUtils.computeElements(array, NullUtils.nonNullMapper(this::someFunc))}</p>
+	 */
+	public <T, R> Function<T, R> nonNullMapper(
+			final @NotNull Function<T, R> mapper
+	) {
+		return (value) -> mapIfPresent(value, mapper);
+	}
+	// CivPatched End
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/serialization/Encoder.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/serialization/Encoder.java
new file mode 100644
index 0000000000000000000000000000000000000000..8330435a4d8c278e4f252bf3b7c062f0ed5de902
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/serialization/Encoder.java
@@ -0,0 +1,136 @@
+package vg.civcraft.mc.civmodcore.utilities.serialization;
+
+import java.util.Objects;
+import java.util.function.Function;
+import lombok.Synchronized;
+import org.bukkit.persistence.PersistentDataAdapterContext;
+import org.bukkit.persistence.PersistentDataType;
+import org.jetbrains.annotations.NotNull;
+import vg.civcraft.mc.civmodcore.nbt.NBTDeserializer;
+import vg.civcraft.mc.civmodcore.nbt.NBTSerializable;
+import vg.civcraft.mc.civmodcore.nbt.NBTSerialization;
+import vg.civcraft.mc.civmodcore.nbt.wrappers.NBTCompound;
+
+/**
+ * This is a class inspired by {@link NBTSerializable} and {@link PersistentDataType} and is designed to act as a bridge
+ * between them while not being specific to either.
+ *
+ * @author CivPatched
+ */
+public interface Encoder<T, R> {
+    @NotNull R encode(@NotNull T instance);
+    @NotNull T decode(@NotNull R raw);
+
+    static <T, R> @NotNull Encoder<T, R> from(
+            final @NotNull Function<@NotNull T, @NotNull R> encoder,
+            final @NotNull Function<@NotNull R, @NotNull T> decoder
+    ) {
+        return new Encoder<>() {
+            @Override
+            public @NotNull R encode(final @NotNull T instance) {
+                return encoder.apply(instance);
+            }
+            @Override
+            public @NotNull T decode(final @NotNull R raw) {
+                return decoder.apply(raw);
+            }
+        };
+    }
+
+    /**
+     * Template that wraps legacy NBT serialization methods.
+     *
+     * @param <C> The type that can be serialised to and from NBT.
+     */
+    class LegacyNBT<C extends NBTSerializable> implements Encoder<C, NBTCompound> {
+        private final NBTDeserializer<C> deserializer;
+
+        /**
+         * @param deserializer The serializable's version of {@link NBTSerializable#fromNBT(NBTCompound) fromNBT(NBTCompound)}
+         */
+        public LegacyNBT(final @NotNull NBTDeserializer<C> deserializer) {
+            this.deserializer = Objects.requireNonNull(deserializer);
+        }
+
+        /**
+         * @param serializableClass The serializable's class to extract the deserializer from.
+         */
+        public LegacyNBT(final @NotNull Class<C> serializableClass) {
+            this(NBTSerialization.getDeserializer(serializableClass));
+        }
+
+        @Override
+        public @NotNull NBTCompound encode(final @NotNull C instance) {
+            final var nbt = new NBTCompound();
+            instance.toNBT(nbt);
+            return nbt;
+        }
+
+        @Override
+        public @NotNull C decode(final @NotNull NBTCompound raw) {
+            return this.deserializer.fromNBT(raw);
+        }
+    }
+
+    /**
+     * Template that wraps PersistentDataContainer serialization.
+     *
+     * @param <C> The <b>C</b>omplex type.
+     * @param <P> The <b>P</b>rimitive type.
+     */
+    abstract class PDC<C, P> implements Encoder<C, P>, PersistentDataType<P, C> {
+        private final Object $lock;
+        private final Class<C> complexClass;
+        private final Class<P> primitiveClass;
+        private PersistentDataAdapterContext adapter;
+
+        public PDC(
+                final @NotNull Class<C> complexClass,
+                final @NotNull Class<P> primitiveClass
+        ) {
+            this.$lock = new Object[0];
+            this.complexClass = Objects.requireNonNull(complexClass);
+            this.primitiveClass = Objects.requireNonNull(primitiveClass);
+        }
+
+        protected final @NotNull PersistentDataAdapterContext getAdapter() {
+            return this.adapter;
+        }
+
+        public final @NotNull Class<C> getComplexType() {
+            return this.complexClass;
+        }
+
+        public final @NotNull Class<P> getPrimitiveType() {
+            return this.primitiveClass;
+        }
+
+        @Deprecated
+        @Synchronized
+        public final @NotNull P toPrimitive(
+                final @NotNull C complex,
+                final @NotNull PersistentDataAdapterContext context
+        ) {
+            synchronized (this.$lock) {
+                this.adapter = context;
+                final P result = encode(complex);
+                this.adapter = null;
+                return result;
+            }
+        }
+
+        @Deprecated
+        @Synchronized
+        public final @NotNull C fromPrimitive(
+                final @NotNull P primitive,
+                final @NotNull PersistentDataAdapterContext context
+        ) {
+            synchronized (this.$lock) {
+                this.adapter = context;
+                final C result = decode(primitive);
+                this.adapter = null;
+                return result;
+            }
+        }
+    }
+}
diff --git a/src/test/java/vg/civcraft/mc/civmodcore/text/TextTests.java b/src/test/java/vg/civcraft/mc/civmodcore/text/TextTests.java
index ba039e91ac3148dae36bf0083cd447715af2ebcc..ad2bb43bbdbe81ac1e950b7faa4ddf04b9c73703 100644
--- a/src/test/java/vg/civcraft/mc/civmodcore/text/TextTests.java
+++ b/src/test/java/vg/civcraft/mc/civmodcore/text/TextTests.java
@@ -7,6 +7,13 @@ import org.junit.jupiter.api.Assertions;
 import org.junit.jupiter.api.Test;
 import vg.civcraft.mc.civmodcore.chat.ChatUtils;
 
+// CivPatched Start
+import java.util.Arrays;
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
+import vg.civcraft.mc.civmodcore.utilities.MoreStringUtils;
+// CivPatched End
+
 public class TextTests {
 
 	/**
@@ -37,4 +44,29 @@ public class TextTests {
 		Assertions.assertTrue(ChatUtils.areComponentsEqual(formerComponent, latterComponent));
 	}
 
+	// CivPatched Start
+	/**
+	 * Tests whether different split methods produce the correct split.
+	 */
+	@Test
+	public void testSplitEquality() {
+		final String exampleString = "\uD83D\uDE00\uD83D\uDE01\uD83D\uDE02"; // 😀😁😂
+		final String[] targetResult = new String[] { "\uD83D\uDE00", "\uD83D\uDE01", "\uD83D\uDE02" };
+		// Assert that "exampleString.toCharArray()" doesn't match "targetResult"
+		Assertions.assertFalse(Arrays.equals(
+				targetResult,
+				ArrayUtils.toStringArray(ArrayUtils.toObject(exampleString.toCharArray()))
+		));
+		// Assert that "StringUtils.split(exampleString, "")" doesn't match "targetResult"
+		Assertions.assertFalse(Arrays.equals(
+				targetResult,
+				StringUtils.split(exampleString, "")
+		));
+		// Assert that "MoreStringUtils.splitStringIntoCharacters(exampleString)" matches "targetResult"
+		Assertions.assertArrayEquals(
+				targetResult,
+				MoreStringUtils.getCharStrings(exampleString)
+		);
+	}
+	// CivPatched End
 }
