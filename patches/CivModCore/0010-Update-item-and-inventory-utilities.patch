From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alexander <protonull@protonmail.com>
Date: Wed, 14 Jun 2023 04:25:04 +0100
Subject: [PATCH] Update item and inventory utilities

Add getRepairable to ItemUtils, which is pretty identical to getDamageable, except it returns the Repairable type instead.

Add getMaterials to MaterialUtils, which returns a Set of all Materials.

Add getBlocksItemMaterial to MaterialUtils and a unit-test for it.

Add getEnchants, clearEnchants, addEnchants, and setEnchants to MetaUtils. And deprecate clearEnchants on EnchantUtils.

Add AmountMap, which is a more robust and efficient replacement of Map<?, Integer> and a preliminary replacement to ItemMap.

Update NBTHelper to use ISerializer.

Standardises NBTSerializationException.

Add cloneContents and wrapContents to InventoryUtils.

diff --git a/src/main/java/vg/civcraft/mc/civmodcore/inventory/InventoryUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/inventory/InventoryUtils.java
index 2f1749f144bd0a95d3740ef8f978d74978313047..5b99b92dc1985591cc9b46cd3507119f6befbba7 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/inventory/InventoryUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/inventory/InventoryUtils.java
@@ -2,20 +2,26 @@ package vg.civcraft.mc.civmodcore.inventory;
 
 import com.google.common.base.Preconditions;
 import java.util.ArrayList;
-import java.util.Arrays;
 import java.util.List;
 import java.util.Map;
 import java.util.stream.Collectors;
 import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
 import lombok.experimental.UtilityClass;
 import org.apache.commons.lang3.ArrayUtils;
-import org.bukkit.Material;
 import org.bukkit.entity.Player;
 import org.bukkit.inventory.Inventory;
 import org.bukkit.inventory.ItemStack;
 import vg.civcraft.mc.civmodcore.inventory.items.ItemUtils;
 
+// CivPatched Start
+import org.bukkit.craftbukkit.v1_18_R2.inventory.CraftInventoryCustom;
+import org.bukkit.inventory.InventoryHolder;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import vg.civcraft.mc.civmodcore.utilities.MoreArrayUtils;
+// CivPatched End
+
 @UtilityClass
 public final class InventoryUtils {
 
@@ -97,11 +103,9 @@ public final class InventoryUtils {
 	 * Clears an inventory of items.
 	 *
 	 * @param inventory The inventory to clear of items.
-	 */
+	 * @deprecated Use {@link Inventory#clear()} instead! */ @Deprecated // CivPatched
 	public static void clearInventory(@Nonnull final Inventory inventory) {
-		final ItemStack[] contents = inventory.getContents();
-		Arrays.fill(contents, new ItemStack(Material.AIR));
-		inventory.setContents(contents);
+		inventory.setContents(new ItemStack[inventory.getSize()]); // CivPatched: Creating a defaulted-array is more efficient
 	}
 
 	/**
@@ -126,6 +130,47 @@ public final class InventoryUtils {
 				&& (slots % 9) == 0;
 	}
 
+	// CivPatched Start
+	/**
+	 * Clones an array of items, useful for {@link Inventory#getContents()} and
+	 * {@link Inventory#getStorageContents()}.
+	 */
+	@Contract("!null -> !null")
+	public ItemStack @Nullable [] cloneContents(
+			ItemStack[] items
+	) {
+		if (ArrayUtils.isNotEmpty(items)) {
+			items = items.clone();
+			MoreArrayUtils.computeElements(items, (item) -> item == null ? null : item.clone());
+		}
+		return items;
+	}
+	/**
+	 * Pretends that a given array of items is an inventory, giving you access
+	 * to inventory methods.
+	 */
+	public @NotNull Inventory wrapContents(
+			final ItemStack @NotNull [] contents
+	) {
+		final var holder = new InventoryHolder() {
+			private final Object $lock = new Object[0];
+			private Inventory inventory;
+			@Override
+			public @NotNull Inventory getInventory() {
+				synchronized (this.$lock) {
+					if (this.inventory == null) {
+						this.inventory = new CraftInventoryCustom(this, contents.length, "");
+					}
+					return this.inventory;
+				}
+			}
+		};
+		final Inventory inventory = holder.getInventory();
+		inventory.setContents(contents);
+		return inventory;
+	}
+	// CivPatched End
+
 	/**
 	 * Will safely add a set of items to an inventory. If not all items are added, it's not committed to the inventory.
 	 *
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/EnchantUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/EnchantUtils.java
index 59749d7b9c7271d5442e43ef2f06ed9ca2d8e6c1..d330c37dab95aade24213a11eaa0bd38e981358a 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/EnchantUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/EnchantUtils.java
@@ -215,12 +215,9 @@ public final class EnchantUtils {
 	 * Removes all enchantments from an item.
 	 *
 	 * @param item The item to clear enchantment from.
-	 */
+	 * @deprecated Use {@link MetaUtils#clearEnchants(ItemMeta)} instead! */ @Deprecated // CivPatched
 	public static void clearEnchantments(@Nonnull final ItemStack item) {
-		ItemUtils.handleItemMeta(Objects.requireNonNull(item), (ItemMeta meta) -> {
-			meta.getEnchants().forEach((key, value) -> meta.removeEnchant(key));
-			return true;
-		});
+		 item.editMeta(MetaUtils::clearEnchants); // CivPatched
 	}
 
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java
index f84ec069bd4bd46c38f473c1eb06d47bce8576c5..cf7f1dc1b28b25a5e7f9279c767bf6e5b4aa8162 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/ItemUtils.java
@@ -18,6 +18,11 @@ import org.bukkit.inventory.meta.ItemMeta;
 import org.jetbrains.annotations.Contract;
 import vg.civcraft.mc.civmodcore.chat.ChatUtils;
 
+// CivPatched Start
+import org.bukkit.inventory.meta.Repairable;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 /**
  * Class of static APIs for Items. Replaces ISUtils.
  */
@@ -188,6 +193,39 @@ public final class ItemUtils {
 		return CraftItemStack.asNMSCopy(item);
 	}
 
+	// CivPatched Start
+	/**
+	 * Splits an item into safely-size stacks based on the given item's amount.
+	 */
+	public static @NotNull List<@NotNull ItemStack> segmentItem(
+			final @NotNull ItemStack template
+	) {
+		return segmentItem(template, template.getAmount());
+	}
+	/**
+	 * Splits an item into safely-sized stacks based on the given amount.
+	 */
+	public static @NotNull List<@NotNull ItemStack> segmentItem(
+			final @NotNull ItemStack template,
+			final int amount
+	) {
+		final int maxStackSize = template.getType().getMaxStackSize();
+		if (maxStackSize > amount) {
+			return Arrays.asList(template.asQuantity(amount)); // Ignore the highlighter, List.of() is unmodifiable
+		}
+		final int fullStacks = amount / maxStackSize;
+		final int partStack = amount % maxStackSize;
+		final List<ItemStack> result = new ArrayList<>(fullStacks + (partStack > 0 ? 1 : 0));
+		for (int i = 0; i < fullStacks; i++) {
+			result.add(template.asQuantity(maxStackSize));
+		}
+		if (partStack > 0) {
+			result.add(template.asQuantity(partStack));
+		}
+		return result;
+	}
+	// CivPatched End
+
 	/**
 	 * Decrements an item's amount, or returns null if the amount reaches zero.
 	 *
@@ -410,6 +448,26 @@ public final class ItemUtils {
 		return null;
 	}
 
+	// CivPatched Start
+	/**
+	 * Retrieves the Repairable ItemMeta only if it's relevant to the item. This is necessary because [almost?] every
+	 * ItemMeta implements Repairable... for some reason. And so this will only return a Repairable instance if the
+	 * item material actually has a maximum durability above zero.
+	 */
+	public static @Nullable Repairable getRepairable(final @Nullable ItemStack item) {
+		if (item == null) {
+			return null;
+		}
+		final Material material = item.getType();
+		if (isValidItemMaterial(material)
+				&& material.getMaxDurability() > 0
+				&& getItemMeta(item) instanceof Repairable repairable) {
+			return repairable;
+		}
+		return null;
+	}
+	// CivPatched End
+
 	/**
 	 * Makes an item glow by adding an enchantment and the flag for hiding enchantments, so it has the enchantment glow
 	 * without an enchantment being visible. Note that this does actually apply an enchantment to an item.
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java
index 7613b5129e55b275e1122e4e709d8b11aa19d568..39156fe52971a264b0b1c014e693d1fb8b3fce36 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MaterialUtils.java
@@ -5,7 +5,6 @@ import com.google.common.math.IntMath;
 import java.util.ArrayList;
 import java.util.List;
 import javax.annotation.Nonnull;
-import javax.annotation.Nullable;
 import lombok.experimental.UtilityClass;
 import net.kyori.adventure.text.Component;
 import net.kyori.adventure.text.TranslatableComponent;
@@ -14,6 +13,16 @@ import org.bukkit.Material;
 import org.bukkit.Tag;
 import org.bukkit.inventory.ItemStack;
 
+// CivPatched Start
+import java.util.HashSet;
+import java.util.Set;
+import org.jetbrains.annotations.Contract;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+import vg.civcraft.mc.civmodcore.utilities.JavaHelpers;
+import vg.civcraft.mc.civmodcore.utilities.MoreCollectionUtils;
+// CivPatched End
+
 /**
  * <p>See <a href="https://github.com/Protonull/BukkitReport/tree/master/reports">BukkitReports</a>.</p>
  *
@@ -34,6 +43,22 @@ public final class MaterialUtils {
 		addAll(MaterialTags.CONCRETES.getValues());
 	}};
 
+	// CivPatched Start
+	public final Set<Material> MATERIALS = JavaHelpers.yield(() -> {
+		final Set<Material> materials = MoreCollectionUtils.collectExact(HashSet::new, Material.values());
+		materials.removeIf(Material::isLegacy);
+		return Set.copyOf(materials);
+	});
+	/**
+	 * @return Returns a new material set. DO NOT USE {@link java.util.EnumSet<Material>}! As it'll force load all
+	 * materials, including all legacy materials, forcing the server into legacy mode. For some reason
+	 * {@link Material#values()} doesn't do that... odd.
+	 */
+	public @NotNull Set<Material> getMaterials() {
+		return new HashSet<>(MATERIALS);
+	}
+	// CivPatched End
+
 	/**
 	 * Attempts to retrieve a material by its slug.
 	 *
@@ -84,4 +109,124 @@ public final class MaterialUtils {
 		return HASH_MATERIALS.get(index);
 	}
 
+	// CivPatched Start
+	/**
+	 * Attempts to match a block material with an item material. For example,
+	 * {@link Material#OAK_WALL_SIGN} with {@link Material#OAK_SIGN}. This is
+	 * useful for GUIs and drops, for example.
+	 */
+	@Contract("null -> null")
+	public @Nullable Material getBlocksItemMaterial(
+			final Material material
+	) {
+		if (material == null || !material.isBlock()) {
+			return null;
+		}
+		if (material.isItem()) {
+			return material;
+		}
+		return switch (material) {
+			// Signs
+			case OAK_WALL_SIGN -> Material.OAK_SIGN;
+			case DARK_OAK_WALL_SIGN -> Material.DARK_OAK_SIGN;
+			case BIRCH_WALL_SIGN -> Material.BIRCH_SIGN;
+			case SPRUCE_WALL_SIGN -> Material.SPRUCE_SIGN;
+			case JUNGLE_WALL_SIGN -> Material.JUNGLE_SIGN;
+			case ACACIA_WALL_SIGN -> Material.ACACIA_SIGN;
+			case WARPED_WALL_SIGN -> Material.WARPED_SIGN;
+			case CRIMSON_WALL_SIGN -> Material.CRIMSON_SIGN;
+
+			// Torches
+			case WALL_TORCH -> Material.TORCH;
+			case SOUL_WALL_TORCH -> Material.SOUL_TORCH;
+			case REDSTONE_WALL_TORCH -> Material.REDSTONE_TORCH;
+
+			// Banners
+			case WHITE_WALL_BANNER -> Material.WHITE_BANNER;
+			case BLACK_WALL_BANNER -> Material.BLACK_BANNER;
+			case BLUE_WALL_BANNER -> Material.BLUE_BANNER;
+			case BROWN_WALL_BANNER -> Material.BROWN_BANNER;
+			case CYAN_WALL_BANNER -> Material.CYAN_BANNER;
+			case GRAY_WALL_BANNER -> Material.GRAY_BANNER;
+			case GREEN_WALL_BANNER -> Material.GREEN_BANNER;
+			case LIGHT_BLUE_WALL_BANNER -> Material.LIGHT_BLUE_BANNER;
+			case LIGHT_GRAY_WALL_BANNER -> Material.LIGHT_GRAY_BANNER;
+			case LIME_WALL_BANNER -> Material.LIME_BANNER;
+			case MAGENTA_WALL_BANNER -> Material.MAGENTA_BANNER;
+			case ORANGE_WALL_BANNER -> Material.ORANGE_BANNER;
+			case PINK_WALL_BANNER -> Material.PINK_BANNER;
+			case PURPLE_WALL_BANNER -> Material.PURPLE_BANNER;
+			case RED_WALL_BANNER -> Material.RED_BANNER;
+			case YELLOW_WALL_BANNER -> Material.YELLOW_BANNER;
+
+			// Heads
+			case DRAGON_WALL_HEAD -> Material.DRAGON_HEAD;
+			case PLAYER_WALL_HEAD -> Material.PLAYER_HEAD;
+			case ZOMBIE_WALL_HEAD -> Material.ZOMBIE_HEAD;
+			case CREEPER_WALL_HEAD -> Material.CREEPER_HEAD;
+			case SKELETON_WALL_SKULL -> Material.SKELETON_SKULL;
+			case WITHER_SKELETON_WALL_SKULL -> Material.WITHER_SKELETON_SKULL;
+
+			// Machines
+			case PISTON_HEAD, MOVING_PISTON -> Material.PISTON;
+			case REDSTONE_WIRE -> Material.REDSTONE;
+			case TRIPWIRE -> Material.STRING;
+
+			// Cauldron (liquid is lost)
+			case WATER_CAULDRON, LAVA_CAULDRON, POWDER_SNOW_CAULDRON -> Material.CAULDRON;
+
+			// Potted Plants (plant is lost)
+			case POTTED_OAK_SAPLING, POTTED_SPRUCE_SAPLING, POTTED_BIRCH_SAPLING, POTTED_JUNGLE_SAPLING,
+					POTTED_ACACIA_SAPLING, POTTED_DARK_OAK_SAPLING, POTTED_FERN, POTTED_DANDELION, POTTED_POPPY,
+					POTTED_BLUE_ORCHID, POTTED_ALLIUM, POTTED_AZURE_BLUET, POTTED_RED_TULIP, POTTED_ORANGE_TULIP,
+					POTTED_WHITE_TULIP, POTTED_PINK_TULIP, POTTED_OXEYE_DAISY, POTTED_CORNFLOWER,
+					POTTED_LILY_OF_THE_VALLEY, POTTED_WITHER_ROSE, POTTED_RED_MUSHROOM, POTTED_BROWN_MUSHROOM,
+					POTTED_DEAD_BUSH, POTTED_CACTUS, POTTED_BAMBOO, POTTED_CRIMSON_FUNGUS, POTTED_WARPED_FUNGUS,
+					POTTED_CRIMSON_ROOTS, POTTED_WARPED_ROOTS, POTTED_AZALEA_BUSH, POTTED_FLOWERING_AZALEA_BUSH -> Material.FLOWER_POT;
+
+			// Plants
+			case CARROTS -> Material.CARROT;
+			case POTATOES -> Material.POTATO;
+			case BEETROOTS -> Material.BEETROOT;
+			case COCOA -> Material.COCOA_BEANS;
+			case ATTACHED_PUMPKIN_STEM, PUMPKIN_STEM -> Material.PUMPKIN_SEEDS;
+			case ATTACHED_MELON_STEM, MELON_STEM -> Material.MELON_SEEDS;
+			case TALL_SEAGRASS -> Material.SEAGRASS;
+			case SWEET_BERRY_BUSH -> Material.SWEET_BERRIES;
+			case KELP_PLANT -> Material.KELP;
+			case BAMBOO_SAPLING -> Material.BAMBOO;
+			case WEEPING_VINES_PLANT -> Material.WEEPING_VINES;
+			case TWISTING_VINES_PLANT -> Material.TWISTING_VINES;
+			case CAVE_VINES, CAVE_VINES_PLANT -> Material.GLOW_BERRIES;
+			case BIG_DRIPLEAF_STEM -> Material.BIG_DRIPLEAF;
+			
+			// Coral
+			case TUBE_CORAL_WALL_FAN -> Material.TUBE_CORAL_FAN;
+			case BRAIN_CORAL_WALL_FAN -> Material.BRAIN_CORAL_FAN;
+			case BUBBLE_CORAL_WALL_FAN -> Material.BUBBLE_CORAL_FAN;
+			case FIRE_CORAL_WALL_FAN -> Material.FIRE_CORAL_FAN;
+			case HORN_CORAL_WALL_FAN -> Material.HORN_CORAL_FAN;
+			// Dead Coral
+			case DEAD_TUBE_CORAL_WALL_FAN -> Material.DEAD_TUBE_CORAL_FAN;
+			case DEAD_BRAIN_CORAL_WALL_FAN -> Material.DEAD_BRAIN_CORAL_FAN;
+			case DEAD_BUBBLE_CORAL_WALL_FAN -> Material.DEAD_BUBBLE_CORAL_FAN;
+			case DEAD_FIRE_CORAL_WALL_FAN -> Material.DEAD_FIRE_CORAL_FAN;
+			case DEAD_HORN_CORAL_WALL_FAN -> Material.DEAD_HORN_CORAL_FAN;
+
+			// Candle Cakes (candle is lost)
+			case CANDLE_CAKE, WHITE_CANDLE_CAKE, ORANGE_CANDLE_CAKE, MAGENTA_CANDLE_CAKE, LIGHT_BLUE_CANDLE_CAKE,
+					YELLOW_CANDLE_CAKE, LIME_CANDLE_CAKE, PINK_CANDLE_CAKE, GRAY_CANDLE_CAKE, LIGHT_GRAY_CANDLE_CAKE,
+					CYAN_CANDLE_CAKE, PURPLE_CANDLE_CAKE, BLUE_CANDLE_CAKE, BROWN_CANDLE_CAKE, GREEN_CANDLE_CAKE,
+					RED_CANDLE_CAKE, BLACK_CANDLE_CAKE -> Material.CAKE;
+
+			// Unobtainable (substituted)
+			case WATER -> Material.WATER_BUCKET;
+			case LAVA -> Material.LAVA_BUCKET;
+			case POWDER_SNOW -> Material.POWDER_SNOW_BUCKET;
+			case FIRE, SOUL_FIRE -> Material.FLINT_AND_STEEL;
+			case FROSTED_ICE -> Material.ICE; // More info: https://minecraft.fandom.com/wiki/Frosted_Ice
+			default -> null;
+		};
+	}
+	// CivPatched End
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MetaUtils.java b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MetaUtils.java
index df12e06426c42e386c8a7367c310ce94e7fa7f94..d20147be5520fc7036b575503ac78a56d3b15752 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MetaUtils.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/inventory/items/MetaUtils.java
@@ -18,6 +18,13 @@ import org.bukkit.inventory.ItemStack;
 import org.bukkit.inventory.meta.ItemMeta;
 import vg.civcraft.mc.civmodcore.chat.ChatUtils;
 
+// CivPatched Start
+import java.util.HashMap;
+import java.util.Map;
+import org.apache.commons.collections4.MapUtils;
+import org.jetbrains.annotations.NotNull;
+// CivPatched End
+
 /**
  * Class of static utilities for when you already have an instance of {@link ItemMeta}, such as inside of
  * {@link ItemUtils#handleItemMeta(ItemStack, Predicate)}'s handler, thus all the methods defined below will assume the
@@ -190,6 +197,49 @@ public final class MetaUtils {
 		meta.lore(lore);
 	}
 
+	// CivPatched Start
+	/**
+	 * Returns a mutable map of enchantments. This is a convenience function
+	 * since {@link ItemMeta#getEnchants()} returns an immutable map.
+	 */
+	public @NotNull Map<Enchantment, Integer> getEnchants(
+			final @NotNull ItemMeta meta
+	) {
+		return new HashMap<>(meta.getEnchants());
+	}
+	/**
+	 * Removes all enchantments.
+	 */
+	public void clearEnchants(
+			final @NotNull ItemMeta meta
+	) {
+		meta.getEnchants().forEach((enchant, level) -> meta.removeEnchant(enchant));
+	}
+	/**
+	 * Adds a given Map of enchantments.
+	 */
+	public void addEnchants(
+			final @NotNull ItemMeta meta,
+			final @NotNull Map<Enchantment, Integer> enchants,
+			final boolean ignoreLevelRestriction
+	) {
+		enchants.forEach((enchant, level) -> meta.addEnchant(enchant, level, ignoreLevelRestriction));
+	}
+	/**
+	 * Replaces all enchantments with the given Map, which can be null.
+	 */
+	public void setEnchants(
+			final @NotNull ItemMeta meta,
+			final Map<Enchantment, Integer> enchants,
+			final boolean ignoreLevelRestriction
+	) {
+		clearEnchants(meta);
+		if (MapUtils.isNotEmpty(enchants)) {
+			addEnchants(meta, enchants, ignoreLevelRestriction);
+		}
+	}
+	// CivPatched End
+
 	/**
 	 * Makes an item glow by adding an enchantment and the flag for hiding enchantments, so it has the enchantment glow
 	 * without an enchantment being visible. Note that this does actually apply an enchantment to an item.
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
index eeeced8ac5c0f39119145f76f0811164d18da730..e0bd7dad25467052623234d2d9b9112da134f743 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
@@ -1,19 +1,29 @@
 package vg.civcraft.mc.civmodcore.nbt;
 
 import java.util.UUID;
-import lombok.experimental.ExtensionMethod;
 import lombok.experimental.UtilityClass;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.inventory.ItemStack;
 import vg.civcraft.mc.civmodcore.inventory.items.ItemUtils;
-import vg.civcraft.mc.civmodcore.nbt.extensions.NBTTagCompoundExtensions;
 import vg.civcraft.mc.civmodcore.nbt.wrappers.NBTCompound;
 import vg.civcraft.mc.civmodcore.utilities.UuidUtils;
 
+// CivPatched Start
+import java.util.logging.Level;
+import net.minecraft.nbt.CompoundTag;
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.inventory.Inventory;
+import org.jetbrains.annotations.NotNull;
+import vg.civcraft.mc.civmodcore.utilities.CivLogger;
+import vg.civcraft.mc.civmodcore.utilities.serialization.ISerializer;
+// CivPatched End
+
 @UtilityClass
-@ExtensionMethod(NBTTagCompoundExtensions.class)
-public final class NBTHelper {
+// CivPatched Start
+public class NBTHelper {
+	private final CivLogger LOGGER = CivLogger.getLogger(NBTHelper.class);
+	// CivPatched End
 
 	// ------------------------------------------------------------
 	// Location
@@ -26,56 +36,143 @@ public final class NBTHelper {
 	private static final String LOCATION_YAW_KEY = "yaw";
 	private static final String LOCATION_PITCH_KEY = "pitch";
 
-	public static Location locationFromNBT(final NBTCompound nbt) {
-		if (nbt == null) {
-			return null;
+	// CivPatched Start
+	public final ISerializer.NBT<Location> LOCATION = new ISerializer.NBT<>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull Location location) {
+			final var nbt = new CompoundTag();
+			try {
+				nbt.putUUID(LOCATION_WORLD_KEY, location.getWorld().getUID());
+			}
+			catch (final Throwable ignored) {
+				nbt.putUUID(LOCATION_WORLD_KEY, UuidUtils.IDENTITY);
+			}
+			nbt.putDouble(LOCATION_X_KEY, location.getX());
+			nbt.putDouble(LOCATION_Y_KEY, location.getY());
+			nbt.putDouble(LOCATION_Z_KEY, location.getZ());
+			final float yaw = location.getYaw();
+			if (yaw != 0) {
+				nbt.putFloat(LOCATION_YAW_KEY, yaw);
+			}
+			final float pitch = location.getPitch();
+			if (pitch != 0) {
+				nbt.putFloat(LOCATION_PITCH_KEY, pitch);
+			}
+			return nbt;
+		}
+		@Override
+		public @NotNull Location deserialize(final @NotNull CompoundTag nbt) {
+			final UUID worldUUID = nbt.getUUID(LOCATION_WORLD_KEY);
+			return new Location(
+					UuidUtils.isNullOrIdentity(worldUUID) ? null : Bukkit.getWorld(worldUUID),
+					nbt.getDouble(LOCATION_X_KEY),
+					nbt.getDouble(LOCATION_Y_KEY),
+					nbt.getDouble(LOCATION_Z_KEY),
+					nbt.getFloat(LOCATION_YAW_KEY),
+					nbt.getFloat(LOCATION_PITCH_KEY));
 		}
-		final UUID worldUUID = nbt.getUUID(LOCATION_WORLD_KEY);
-		return new Location(
-				UuidUtils.isNullOrIdentity(worldUUID) ? null : Bukkit.getWorld(worldUUID),
-				nbt.getDouble(LOCATION_X_KEY),
-				nbt.getDouble(LOCATION_Y_KEY),
-				nbt.getDouble(LOCATION_Z_KEY),
-				nbt.getFloat(LOCATION_YAW_KEY),
-				nbt.getFloat(LOCATION_PITCH_KEY));
+	};
+	// CivPatched End
+
+	public static Location locationFromNBT(final NBTCompound nbt) {
+		return nbt == null ? null : LOCATION.deserialize(nbt.getRAW()); // CivPatched
 	}
 
 	public static NBTCompound locationToNBT(final Location location) {
-		if (location == null) {
-			return null;
-		}
-		final var nbt = new NBTCompound();
-		nbt.setUUID(LOCATION_WORLD_KEY, location.isWorldLoaded() ? location.getWorld().getUID() : UuidUtils.IDENTITY);
-		nbt.setDouble(LOCATION_X_KEY, location.getX());
-		nbt.setDouble(LOCATION_Y_KEY, location.getY());
-		nbt.setDouble(LOCATION_Z_KEY, location.getZ());
-		if (location.getYaw() != 0) {
-			nbt.setFloat(LOCATION_YAW_KEY, location.getYaw());
-		}
-		if (location.getPitch() != 0) {
-			nbt.setFloat(LOCATION_PITCH_KEY, location.getPitch());
-		}
-		return nbt;
+		return location == null ? null : new NBTCompound(LOCATION.serialize(location)); // CivPatched
 	}
 
 	// ------------------------------------------------------------
 	// ItemStack
 	// ------------------------------------------------------------
 
-	public static ItemStack itemStackFromNBT(final NBTCompound nbt) {
-		if (nbt == null) {
-			return null;
+	// CivPatched Start
+	public final ISerializer.NBT<ItemStack> ITEMSTACK = new ISerializer.NBT<>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull ItemStack item) {
+			final var nbt = new CompoundTag();
+			ItemUtils.getNMSItemStack(item).save(nbt);
+			return nbt;
+		}
+		@Override
+		public @NotNull ItemStack deserialize(final @NotNull CompoundTag nbt) {
+			return net.minecraft.world.item.ItemStack.of(nbt).getBukkitStack();
 		}
-		return net.minecraft.world.item.ItemStack.of(nbt.getRAW()).getBukkitStack();
+	};
+	// CivPatched End
+
+	public static ItemStack itemStackFromNBT(final NBTCompound nbt) {
+		return nbt == null ? null : ITEMSTACK.deserialize(nbt.getRAW()); // CivPatched
 	}
 
 	public static NBTCompound itemStackToNBT(final ItemStack item) {
-		if (item == null) {
-			return null;
-		}
-		final var nbt = new NBTCompound();
-		ItemUtils.getNMSItemStack(item).save(nbt.getRAW());
-		return nbt;
+		return item == null ? null : new NBTCompound(ITEMSTACK.serialize(item)); // CivPatched
 	}
 
+	// ------------------------------------------------------------
+	// Inventory
+	// ------------------------------------------------------------
+
+	// CivPatched Start
+	public final ISerializer.NBT<Inventory> INVENTORY = new ISerializer.NBT<Inventory>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull Inventory inventory) {
+			final var nbt = new CompoundTag();
+			final ItemStack[] contents = inventory.getContents();
+			for (int i = 0; i < contents.length; i++) {
+				final ItemStack item = contents[i];
+				if (!ItemUtils.isEmptyItem(item)) {
+					nbt.put(Integer.toString(i), ITEMSTACK.serialize(item));
+				}
+			}
+			return nbt;
+		}
+		public void deserialize(
+				final @NotNull Inventory inventory,
+				final @NotNull CompoundTag nbt
+		) {
+			inventory.clear();
+			final ItemStack[] contents = inventory.getContents();
+			for (final String key : nbt.getAllKeys()) {
+				if (!(nbt.get(key) instanceof final CompoundTag compound)) {
+					LOGGER.log(
+							Level.WARNING,
+							"Inventory slot [" + key + "] is not a parsable NBT compound!",
+							new RuntimeException()
+					);
+					continue;
+				}
+				final ItemStack parsed = ITEMSTACK.deserialize(compound);
+				if (ItemUtils.isEmptyItem(parsed)) {
+					// Just ignore empty items
+					continue;
+				}
+				final int index;
+				try {
+					index = Integer.parseInt(key);
+				}
+				catch (final NumberFormatException thrown) {
+					LOGGER.log(Level.WARNING,
+							"Inventory slot [" + key + "] not a valid number! Item[" + parsed + "] will be ignored.",
+							new RuntimeException());
+					continue;
+				}
+				if (index < 0 || index >= contents.length) {
+					LOGGER.log(Level.WARNING,
+							"Inventory slot [" + index + "] is out of bounds of array[" + contents.length + "]! Item[" + parsed + "] will be ignored.",
+							new RuntimeException());
+					continue;
+				}
+				contents[index] = parsed;
+			}
+			inventory.setContents(contents);
+		}
+		@Deprecated
+		@Override
+		public @NotNull Inventory deserialize(final @NotNull CompoundTag raw) {
+			throw new NotImplementedException();
+		}
+	};
+	// CivPatched End
+
 }
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java
index 8b4eb90deac0e9fc34c62448177b3e7fad6d49bc..3586d1e72aee2fa9b5b16e752131a3ad66e344e8 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTSerializationException.java
@@ -7,25 +7,10 @@ import vg.civcraft.mc.civmodcore.nbt.wrappers.NBTCompound;
  * Exception that ought to be used within {@link NBTSerializable#toNBT(NBTCompound)} and
  * {@link NBTSerializable#fromNBT(NBTCompound)}.
  */
+@lombok.experimental.StandardException // CivPatched
 public class NBTSerializationException extends RuntimeException {
 
 	@Serial
 	private static final long serialVersionUID = 606023177729327630L;
 
-	public NBTSerializationException() {
-		super();
-	}
-
-	public NBTSerializationException(String message) {
-		super(message);
-	}
-
-	public NBTSerializationException(String message, Throwable cause) {
-		super(message, cause);
-	}
-
-	public NBTSerializationException(Throwable cause) {
-		super(cause);
-	}
-
 }
\ No newline at end of file
diff --git a/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java b/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java
new file mode 100644
index 0000000000000000000000000000000000000000..7ef13fec94d69ad677a04f3667bcbe260785adbf
--- /dev/null
+++ b/src/main/java/vg/civcraft/mc/civmodcore/utilities/AmountMap.java
@@ -0,0 +1,129 @@
+package vg.civcraft.mc.civmodcore.utilities;
+
+import it.unimi.dsi.fastutil.ints.Int2IntFunction;
+import it.unimi.dsi.fastutil.objects.Object2IntArrayMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMap;
+import it.unimi.dsi.fastutil.objects.Object2IntMaps;
+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;
+import java.util.Objects;
+import org.apache.commons.lang3.NotImplementedException;
+import org.jetbrains.annotations.NotNull;
+
+/**
+ * An attempt to fix the ever-present problem of tracking amounts. There are two default implementations:
+ * {@link ArrayMap} and {@link HashMap}. Be aware that this class doesn't support key preprocessing, so you <i>will</i>
+ * need to manually call {@link org.bukkit.inventory.ItemStack#asOne()} for example if you intend to use items.
+ *
+ * @author CivPatched
+ */
+public interface AmountMap<T> extends Object2IntMap<T> {
+
+	/**
+	 * Removes "empties", ie: keys with non-positive amounts.
+	 */
+	default void removeEmpties() {
+		values().removeIf((final int amount) -> amount <= 0);
+	}
+
+	/**
+	 * @return Returns the total amount of things stored in this map.
+	 */
+	default int getTotalAmount() {
+		int amount = 0;
+		for (final int currentAmount : values()) {
+			if (currentAmount > 0) {
+				amount += currentAmount;
+			}
+		}
+		return amount;
+	}
+
+	/**
+	 * Computes the amount for a certain key. If the computer returns a non-positive amount, the key is considered
+	 * "empty" and will be removed.
+	 *
+	 * @param key The key to compute the amount of.
+	 * @param computer The computer method/lambda to call.
+	 * @return Returns the new amount value, or zero if "empty".
+	 */
+	default int computeAmount(
+            final T key,
+            final @NotNull Int2IntFunction computer
+    ) {
+		return computeInt(key, (final T _key, Integer amount) -> {
+			amount = computer.applyAsInt(amount == null ? defaultReturnValue() : amount);
+			return amount <= 0 ? null : amount;
+		});
+	}
+
+	/**
+	 * Convenience method to add a particular amount to a given key.
+	 *
+	 * @param key The key to add to.
+	 * @param amount The amount to add, which can be null.
+	 * @return Returns the new amount value, or zero if "empty".
+	 */
+	default int changeAmountBy(
+            final T key,
+            final int amount
+    ) {
+		return computeAmount(key, (final int currentAmount) -> currentAmount + amount);
+	}
+
+	/**
+	 * @deprecated Changing the default value from 0 in an amount map is not supported!
+	 */
+	@Deprecated
+	@Override
+	default void defaultReturnValue(final int returnValue) {
+		throw new NotImplementedException("Please don't try to change the default return value!");
+	}
+
+	// ------------------------------------------------------------
+	// Default Implementations
+	// ------------------------------------------------------------
+
+	/**
+	 * Predefined increment method useful for {@link #computeAmount(Object, Int2IntFunction)}.
+	 */
+	Int2IntFunction INCREMENT = (final int amount) -> amount + 1;
+
+	/**
+	 * Predefined decrement method useful for {@link #computeAmount(Object, Int2IntFunction)}.
+	 */
+	Int2IntFunction DECREMENT = (final int amount) -> amount - 1;
+
+	/**
+	 * Array-map implementation class for {@link AmountMap}.
+	 */
+	class ArrayMap<T> extends Object2IntArrayMap<T> implements AmountMap<T> {
+		public ArrayMap() {
+			this(16);
+		}
+		public ArrayMap(final int size) {
+			super(size);
+		}
+	}
+
+	/**
+	 * Hash-map implementation class for {@link AmountMap}.
+	 */
+	class HashMap<T> extends Object2IntOpenHashMap<T> implements AmountMap<T> {
+		public HashMap() {
+			this(16);
+		}
+		public HashMap(final int size) {
+			super(size);
+		}
+	}
+
+	/**
+	 * Wrapper class to make an {@link AmountMap} unmodifiable.
+	 */
+	class Unmodifiable<T> extends Object2IntMaps.UnmodifiableMap<T> implements AmountMap<T> {
+		public Unmodifiable(final @NotNull AmountMap<T> map) {
+			super(Objects.requireNonNull(map));
+		}
+	}
+
+}
\ No newline at end of file
diff --git a/src/test/java/vg/civcraft/mc/civmodcore/items/MissingMaterialsTests.java b/src/test/java/vg/civcraft/mc/civmodcore/items/MissingMaterialsTests.java
new file mode 100644
index 0000000000000000000000000000000000000000..40f94eb4f83a12c491fa7243d5cb1a646938f88e
--- /dev/null
+++ b/src/test/java/vg/civcraft/mc/civmodcore/items/MissingMaterialsTests.java
@@ -0,0 +1,51 @@
+package vg.civcraft.mc.civmodcore.items;
+
+import java.util.Set;
+import net.kyori.adventure.text.Component;
+import org.apache.commons.lang3.StringUtils;
+import org.bukkit.Material;
+import org.bukkit.pseudo.PseudoServer;
+import org.junit.jupiter.api.BeforeAll;
+import org.junit.jupiter.api.Test;
+import vg.civcraft.mc.civmodcore.chat.ChatUtils;
+import vg.civcraft.mc.civmodcore.inventory.items.MaterialUtils;
+
+/**
+ * @author CivPatched
+ */
+public class MissingMaterialsTests {
+
+    @BeforeAll
+    public static void setupBukkit() {
+        PseudoServer.setup();
+    }
+
+    /**
+     * Tests whether {@link ChatUtils#isBaseComponent(Component)} works.
+     */
+    //@Test // Uncomment when MaterialUtils.HASH_MATERIALS stops throwing errors
+    public void testMissingRepresentativeItems() {
+        final Set<Material> missing = MaterialUtils.getMaterials();
+        // Remove materials that aren't blocks or are already items, or are legacy materials.
+        missing.removeIf((material) -> !material.isBlock() || material.isLegacy());
+        // Remove materials that are matched.
+        missing.removeIf((material) -> {
+            material = MaterialUtils.getBlocksItemMaterial(material);
+            return material != null && material.isItem();
+        });
+        // Remove impossible materials.
+        missing.removeAll(Set.of(
+                Material.AIR,
+                Material.CAVE_AIR,
+                Material.VOID_AIR,
+                Material.NETHER_PORTAL,
+                Material.END_PORTAL,
+                Material.END_GATEWAY,
+                Material.BUBBLE_COLUMN
+        ));
+        if (!missing.isEmpty()) {
+            throw new IllegalStateException("The following Materials do not have an matching item material!: " + StringUtils.join(missing, ","));
+        }
+    }
+
+}
