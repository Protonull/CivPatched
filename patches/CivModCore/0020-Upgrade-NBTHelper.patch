From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alexander <protonull@protonmail.com>
Date: Sat, 13 May 2023 18:41:33 +0100
Subject: [PATCH] Upgrade NBTHelper


diff --git a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
index eeeced8ac5c0f39119145f76f0811164d18da730..e0bd7dad25467052623234d2d9b9112da134f743 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/nbt/NBTHelper.java
@@ -1,19 +1,29 @@
 package vg.civcraft.mc.civmodcore.nbt;
 
 import java.util.UUID;
-import lombok.experimental.ExtensionMethod;
 import lombok.experimental.UtilityClass;
 import org.bukkit.Bukkit;
 import org.bukkit.Location;
 import org.bukkit.inventory.ItemStack;
 import vg.civcraft.mc.civmodcore.inventory.items.ItemUtils;
-import vg.civcraft.mc.civmodcore.nbt.extensions.NBTTagCompoundExtensions;
 import vg.civcraft.mc.civmodcore.nbt.wrappers.NBTCompound;
 import vg.civcraft.mc.civmodcore.utilities.UuidUtils;
 
+// CivPatched Start
+import java.util.logging.Level;
+import net.minecraft.nbt.CompoundTag;
+import org.apache.commons.lang3.NotImplementedException;
+import org.bukkit.inventory.Inventory;
+import org.jetbrains.annotations.NotNull;
+import vg.civcraft.mc.civmodcore.utilities.CivLogger;
+import vg.civcraft.mc.civmodcore.utilities.serialization.ISerializer;
+// CivPatched End
+
 @UtilityClass
-@ExtensionMethod(NBTTagCompoundExtensions.class)
-public final class NBTHelper {
+// CivPatched Start
+public class NBTHelper {
+	private final CivLogger LOGGER = CivLogger.getLogger(NBTHelper.class);
+	// CivPatched End
 
 	// ------------------------------------------------------------
 	// Location
@@ -26,56 +36,143 @@ public final class NBTHelper {
 	private static final String LOCATION_YAW_KEY = "yaw";
 	private static final String LOCATION_PITCH_KEY = "pitch";
 
-	public static Location locationFromNBT(final NBTCompound nbt) {
-		if (nbt == null) {
-			return null;
+	// CivPatched Start
+	public final ISerializer.NBT<Location> LOCATION = new ISerializer.NBT<>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull Location location) {
+			final var nbt = new CompoundTag();
+			try {
+				nbt.putUUID(LOCATION_WORLD_KEY, location.getWorld().getUID());
+			}
+			catch (final Throwable ignored) {
+				nbt.putUUID(LOCATION_WORLD_KEY, UuidUtils.IDENTITY);
+			}
+			nbt.putDouble(LOCATION_X_KEY, location.getX());
+			nbt.putDouble(LOCATION_Y_KEY, location.getY());
+			nbt.putDouble(LOCATION_Z_KEY, location.getZ());
+			final float yaw = location.getYaw();
+			if (yaw != 0) {
+				nbt.putFloat(LOCATION_YAW_KEY, yaw);
+			}
+			final float pitch = location.getPitch();
+			if (pitch != 0) {
+				nbt.putFloat(LOCATION_PITCH_KEY, pitch);
+			}
+			return nbt;
+		}
+		@Override
+		public @NotNull Location deserialize(final @NotNull CompoundTag nbt) {
+			final UUID worldUUID = nbt.getUUID(LOCATION_WORLD_KEY);
+			return new Location(
+					UuidUtils.isNullOrIdentity(worldUUID) ? null : Bukkit.getWorld(worldUUID),
+					nbt.getDouble(LOCATION_X_KEY),
+					nbt.getDouble(LOCATION_Y_KEY),
+					nbt.getDouble(LOCATION_Z_KEY),
+					nbt.getFloat(LOCATION_YAW_KEY),
+					nbt.getFloat(LOCATION_PITCH_KEY));
 		}
-		final UUID worldUUID = nbt.getUUID(LOCATION_WORLD_KEY);
-		return new Location(
-				UuidUtils.isNullOrIdentity(worldUUID) ? null : Bukkit.getWorld(worldUUID),
-				nbt.getDouble(LOCATION_X_KEY),
-				nbt.getDouble(LOCATION_Y_KEY),
-				nbt.getDouble(LOCATION_Z_KEY),
-				nbt.getFloat(LOCATION_YAW_KEY),
-				nbt.getFloat(LOCATION_PITCH_KEY));
+	};
+	// CivPatched End
+
+	public static Location locationFromNBT(final NBTCompound nbt) {
+		return nbt == null ? null : LOCATION.deserialize(nbt.getRAW()); // CivPatched
 	}
 
 	public static NBTCompound locationToNBT(final Location location) {
-		if (location == null) {
-			return null;
-		}
-		final var nbt = new NBTCompound();
-		nbt.setUUID(LOCATION_WORLD_KEY, location.isWorldLoaded() ? location.getWorld().getUID() : UuidUtils.IDENTITY);
-		nbt.setDouble(LOCATION_X_KEY, location.getX());
-		nbt.setDouble(LOCATION_Y_KEY, location.getY());
-		nbt.setDouble(LOCATION_Z_KEY, location.getZ());
-		if (location.getYaw() != 0) {
-			nbt.setFloat(LOCATION_YAW_KEY, location.getYaw());
-		}
-		if (location.getPitch() != 0) {
-			nbt.setFloat(LOCATION_PITCH_KEY, location.getPitch());
-		}
-		return nbt;
+		return location == null ? null : new NBTCompound(LOCATION.serialize(location)); // CivPatched
 	}
 
 	// ------------------------------------------------------------
 	// ItemStack
 	// ------------------------------------------------------------
 
-	public static ItemStack itemStackFromNBT(final NBTCompound nbt) {
-		if (nbt == null) {
-			return null;
+	// CivPatched Start
+	public final ISerializer.NBT<ItemStack> ITEMSTACK = new ISerializer.NBT<>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull ItemStack item) {
+			final var nbt = new CompoundTag();
+			ItemUtils.getNMSItemStack(item).save(nbt);
+			return nbt;
+		}
+		@Override
+		public @NotNull ItemStack deserialize(final @NotNull CompoundTag nbt) {
+			return net.minecraft.world.item.ItemStack.of(nbt).getBukkitStack();
 		}
-		return net.minecraft.world.item.ItemStack.of(nbt.getRAW()).getBukkitStack();
+	};
+	// CivPatched End
+
+	public static ItemStack itemStackFromNBT(final NBTCompound nbt) {
+		return nbt == null ? null : ITEMSTACK.deserialize(nbt.getRAW()); // CivPatched
 	}
 
 	public static NBTCompound itemStackToNBT(final ItemStack item) {
-		if (item == null) {
-			return null;
-		}
-		final var nbt = new NBTCompound();
-		ItemUtils.getNMSItemStack(item).save(nbt.getRAW());
-		return nbt;
+		return item == null ? null : new NBTCompound(ITEMSTACK.serialize(item)); // CivPatched
 	}
 
+	// ------------------------------------------------------------
+	// Inventory
+	// ------------------------------------------------------------
+
+	// CivPatched Start
+	public final ISerializer.NBT<Inventory> INVENTORY = new ISerializer.NBT<Inventory>() {
+		@Override
+		public @NotNull CompoundTag serialize(final @NotNull Inventory inventory) {
+			final var nbt = new CompoundTag();
+			final ItemStack[] contents = inventory.getContents();
+			for (int i = 0; i < contents.length; i++) {
+				final ItemStack item = contents[i];
+				if (!ItemUtils.isEmptyItem(item)) {
+					nbt.put(Integer.toString(i), ITEMSTACK.serialize(item));
+				}
+			}
+			return nbt;
+		}
+		public void deserialize(
+				final @NotNull Inventory inventory,
+				final @NotNull CompoundTag nbt
+		) {
+			inventory.clear();
+			final ItemStack[] contents = inventory.getContents();
+			for (final String key : nbt.getAllKeys()) {
+				if (!(nbt.get(key) instanceof final CompoundTag compound)) {
+					LOGGER.log(
+							Level.WARNING,
+							"Inventory slot [" + key + "] is not a parsable NBT compound!",
+							new RuntimeException()
+					);
+					continue;
+				}
+				final ItemStack parsed = ITEMSTACK.deserialize(compound);
+				if (ItemUtils.isEmptyItem(parsed)) {
+					// Just ignore empty items
+					continue;
+				}
+				final int index;
+				try {
+					index = Integer.parseInt(key);
+				}
+				catch (final NumberFormatException thrown) {
+					LOGGER.log(Level.WARNING,
+							"Inventory slot [" + key + "] not a valid number! Item[" + parsed + "] will be ignored.",
+							new RuntimeException());
+					continue;
+				}
+				if (index < 0 || index >= contents.length) {
+					LOGGER.log(Level.WARNING,
+							"Inventory slot [" + index + "] is out of bounds of array[" + contents.length + "]! Item[" + parsed + "] will be ignored.",
+							new RuntimeException());
+					continue;
+				}
+				contents[index] = parsed;
+			}
+			inventory.setContents(contents);
+		}
+		@Deprecated
+		@Override
+		public @NotNull Inventory deserialize(final @NotNull CompoundTag raw) {
+			throw new NotImplementedException();
+		}
+	};
+	// CivPatched End
+
 }
