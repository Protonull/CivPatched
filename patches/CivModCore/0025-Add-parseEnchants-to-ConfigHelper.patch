From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Alexander <protonull@protonmail.com>
Date: Thu, 18 May 2023 15:20:20 +0100
Subject: [PATCH] Add parseEnchants to ConfigHelper

And update parseItemMapDirectly to use it.

diff --git a/src/main/java/vg/civcraft/mc/civmodcore/config/ConfigHelper.java b/src/main/java/vg/civcraft/mc/civmodcore/config/ConfigHelper.java
index f7bf058b8f144a294f5ff755667297ca7125efca..73594c6acc43127be5536048f7a265e56a1f0b71 100644
--- a/src/main/java/vg/civcraft/mc/civmodcore/config/ConfigHelper.java
+++ b/src/main/java/vg/civcraft/mc/civmodcore/config/ConfigHelper.java
@@ -16,7 +16,6 @@ import org.bukkit.Bukkit;
 import org.bukkit.Color;
 import org.bukkit.Location;
 import org.bukkit.Material;
-import org.bukkit.NamespacedKey;
 import org.bukkit.World;
 import org.bukkit.configuration.ConfigurationSection;
 import org.bukkit.enchantments.Enchantment;
@@ -234,27 +233,7 @@ public final class ConfigHelper {
 					meta.addItemFlags(flag);
 				}
 			}
-			if (current.contains("enchants")) {
-				for (String enchantKey : current.getConfigurationSection("enchants").getKeys(false)) {
-					ConfigurationSection enchantConfig = current.getConfigurationSection("enchants")
-							.getConfigurationSection(enchantKey);
-					if (!enchantConfig.isString("enchant")) {
-						LOGGER.warning("No enchant specified for enchantment entry at " + enchantConfig.getCurrentPath()
-								+ ". Entry was ignored");
-						continue;
-					}
-					Enchantment enchant;
-					enchant = Enchantment
-							.getByKey(NamespacedKey.minecraft((enchantConfig.getString("enchant").toLowerCase())));
-					if (enchant == null) {
-						LOGGER.severe("Failed to parse enchantment " + enchantConfig.getString("enchant")
-								+ ", the entry was ignored");
-						continue;
-					}
-					int level = enchantConfig.getInt("level", 1);
-					meta.addEnchant(enchant, level, true);
-				}
-			}
+			parseEnchants(current.getConfigurationSection("enchants")).forEach((enchant, level) -> meta.addEnchant(enchant, level, true)); // CivPatched
 			if (m == Material.LEATHER_BOOTS || m == Material.LEATHER_CHESTPLATE || m == Material.LEATHER_HELMET
 					|| m == Material.LEATHER_LEGGINGS) {
 				ConfigurationSection color = current.getConfigurationSection("color");
@@ -278,25 +257,7 @@ public final class ConfigHelper {
 				}
 			}
 			if (m == Material.ENCHANTED_BOOK) {
-				ConfigurationSection storedEnchantSection = current.getConfigurationSection("stored_enchants");
-				if (storedEnchantSection != null) {
-					EnchantmentStorageMeta enchantMeta = (EnchantmentStorageMeta) meta;
-					for (String sEKey : storedEnchantSection.getKeys(false)) {
-						ConfigurationSection currentStoredEnchantSection = storedEnchantSection
-								.getConfigurationSection(sEKey);
-						if (currentStoredEnchantSection != null) {
-							Enchantment enchant = EnchantUtils.getEnchantment(currentStoredEnchantSection.getString("enchant"));
-							int level = currentStoredEnchantSection.getInt("level", 1);
-							if (enchant != null) {
-								enchantMeta.addStoredEnchant(enchant, level, true);
-							}
-							else {
-								LOGGER.severe("Failed to parse enchantment at " + currentStoredEnchantSection.getCurrentPath()
-										+ ", it was not applied");
-							}
-						}
-					}
-				}
+				parseEnchants(current.getConfigurationSection("stored_enchants")).forEach((enchant, level) -> ((EnchantmentStorageMeta) meta).addStoredEnchant(enchant, level, true)); // CivPatched
 			}
 			if (m == Material.POTION || m == Material.SPLASH_POTION || m == Material.LINGERING_POTION
 					|| m == Material.TIPPED_ARROW) {
@@ -338,6 +299,74 @@ public final class ConfigHelper {
 		return im;
 	}
 
+	// CivPatched Start
+	/**
+	 * Parses enchants from a given config section. Supports legacy config structures.
+	 *
+	 * @param config The config section to parse enchants from.
+	 * @return Returns a map of enchants, which is never null.
+	 */
+	public @NotNull Map<Enchantment, Integer> parseEnchants(final ConfigurationSection config) {
+		if (config == null) {
+			return new java.util.HashMap<>(0);
+		}
+		final var keys = config.getKeys(false);
+		final var enchants = new java.util.HashMap<Enchantment, Integer>(keys.size());
+		for (final String key : keys) {
+			final Object value = config.get(key, null);
+			final String rawEnchant;
+			final int level;
+			// Legacy support, like so
+			//   th:
+			//     enchant: THORNS
+			//     level: 1
+			//   kb:
+			//     enchant: KNOCKBACK
+			//     level: 2
+			if (value instanceof final ConfigurationSection enchantSection) {
+				rawEnchant = enchantSection.getString("enchant", null);
+				level = enchantSection.getInt("level", 1);
+			}
+			// Modern parsing, like so
+			//   THORNS: 1
+			//   KNOCKBACK: 2
+			else {
+				rawEnchant = key;
+				if (value instanceof final Number rawLevel) {
+					level = rawLevel.intValue();
+				}
+				else if (value instanceof final String rawLevel) {
+					try {
+						level = Integer.parseInt(rawLevel);
+					}
+					catch (final NumberFormatException thrown) {
+						LOGGER.warning("Could not parse \"" + rawLevel + "\" as an enchant level for "
+								+ "\"" + rawEnchant + "\" at " + config.getCurrentPath());
+						continue;
+					}
+				}
+				// Otherwise, it's unknown
+				else {
+					LOGGER.warning("Unsupported enchant section \"" + key + "\" at " + config.getCurrentPath());
+					continue;
+				}
+			}
+			final Enchantment enchant = EnchantUtils.getEnchantment(rawEnchant);
+			if (enchant == null) {
+				LOGGER.warning("Could not match \"" + rawEnchant + "\" with an enchant at " + config.getCurrentPath());
+				continue;
+			}
+			if (level < enchant.getStartLevel() || level > enchant.getMaxLevel()) {
+				LOGGER.warning("Be aware that enchant \"" + rawEnchant + "\" is set to \"" + level + "\" even "
+						+ "though it's minimum level is \"" + enchant.getStartLevel() + "\" and its maximum level "
+						+ "level is \"" + enchant.getMaxLevel() + "\"!");
+			}
+			enchants.put(enchant, level);
+		}
+		return enchants;
+	}
+	// CivPatched End
+
 	public static int parseTimeAsTicks(@Nonnull final String arg) {
 		return (int) (parseTime(arg, TimeUnit.MILLISECONDS) / 50L);
 	}
